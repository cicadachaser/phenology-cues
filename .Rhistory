for (i in 1:length(davis.yearnames)){
davis.yearlist[[i]]$DAY.OF.YEAR<-julian(davis.yearlist[[i]]$DATE2, origin=as.Date(paste(davis.yearnames[i],"01","01",sep="-")))+1 #add +1 so that the first day of the year is 1, not zero.
}
#CURRENTLY IN THE "SLOW AND CORRECT" STAGE
#optimize AFTER we confirm it works
#clear all variables
rm(list=ls())
#libraries
library(timeDate)
library(Cairo) #I'm not sure if we need this with the plotting removed
#Set appropriate working directory
if(Sys.getenv("USERNAME")=="Collin" || Sys.getenv("USERNAME")=="collin"){ #If it's collin
if(Sys.info()[1]=="Linux"){
setwd("/home/collin/Dropbox/Grad school/research projects/yang_cue")
}else{
setwd("C:\\Repos\\phenology-cues") #desktop
}
}else{
if(Sys.getenv("COMPUTERNAME")=="ENT-YANG01"){
setwd("C:\\Users\\lhyang.ent-yang01\\SkyDrive\\Phenology simulation\\phenology-cues")#desktop
}else{
setwd("C:\\Users\\lhyang\\Skydrive\\Phenology simulation\\phenology-cues")} #laptop
}
#Load sources file(s)
source("windows_subs.R")
#########################
# Simulation parameters #
#########################
#generations has been removed. instead simulation runs for the number of years in years.index
duration=10
best.temp=15; sd.temp=10; #The optimal temp and the sd for the temp-by-fitness curve (which is gaussian)
best.precip=55; sd.precip=30; #The optimal precip and the sd for the precip-by-fitness curve (which is gaussian)
N=40 #number of individuals
start<-data.frame(  #this represents the min and max values used when randomly assigning initial values to the population
constmin=0,constmax=5,
daymin=0,daymax=2,
tempmin=0,tempmax=10,
precipmin=0,precipmax=2)
sds<-data.frame( #standard deviations for trait mutations. Currently set so that variance = max initial trait value
const=sqrt(start$constmax),
day=sqrt(start$daymax),
temp=sqrt(start$tempmax),
precip=sqrt(start$precipmax))
mutrate<-data.frame( #probability of each trait mutating in an individual. Mutations are independent of one another
const=.1,
day=.1,
temp=.1,
precip=.1)
#input data
davis.daily<-read.csv("davis-data/626713.csv", header=T, na.strings="-9999")
davis.daily$PRCP<-davis.daily$PRCP/10 #precips are reported in tenths of mm
davis.daily$TMAX<-davis.daily$TMAX/10 #temps are reported in tenths of degree C
davis.daily$TMIN<-davis.daily$TMIN/10 #temps are reported in tenths of degree C
davis.daily$DATE2<-as.Date(as.character(davis.daily$DATE),format="%Y %m %d") #DATE2 is date formatted
davis.daily$JULIAN<-julian(davis.daily$DATE2,origin=as.Date("1892-12-31")) #1893-01-01 is day 1...
davis.daily$YEAR<-as.numeric(substr(davis.daily$DATE,1,4)) #simple field for year
davis.daily$MONTH<-as.numeric(substr(davis.daily$DATE,5,6)) #simple field for month
davis.daily$DAY<-as.numeric(substr(davis.daily$DATE,7,8)) #simple field for day
davis.daily<-davis.daily[,c("DATE2","JULIAN", "YEAR","MONTH","DAY","PRCP","TMAX","TMIN")] #simplified dataframe
davis.yearlist<-split(davis.daily,davis.daily$YEAR) #list of each year separated
#calculates the "day of year", i.e. Jan 1 is 1, and 12/31 is 365
#adds a DAY.OF.YEAR column to each dataframe in the year list
davis.yearnames<-unique(davis.daily$YEAR)
for (i in 1:length(davis.yearnames)){
davis.yearlist[[i]]$DAY.OF.YEAR<-julian(davis.yearlist[[i]]$DATE2, origin=as.Date(paste(davis.yearnames[i],"01","01",sep="-")))+1 #add +1 so that the first day of the year is 1, not zero.
}
yearlist.store=davis.yearlist
goodyears=NULL
for(iyear in davis.yearnames){
nacount=sum(sum(is.na(davis.yearlist[[as.character(iyear)]])))
daycount=dim(davis.yearlist[[as.character(iyear)]])[1]
if(nacount==0 & daycount>364){goodyears=c(goodyears,iyear)}
}
davis.yearlist=davis.yearlist[as.character(goodyears)]
davis.yearnames<-goodyears #gives a list of all the years in the data
davis.daily<-unsplit(yearlist.store,davis.daily$YEAR) #using legacy "yearlist.store" to make unsplit happy
# DAY.OF.YEAR=rep(0,dim(davis.daily)[1])
# for(i in 1:length(DAY.OF.YEAR)){
#   DAY.OF.YEAR[i]=sprintf("%02d%02d",davis.daily[i,"MONTH"],davis.daily[i,"DAY"])
#
# }
# davis.daily=cbind(davis.daily, DAY.OF.YEAR)
# davis.daily<-unsplit(davis.daily,davis.daily$YEAR)
davis.daily.means<-aggregate(cbind(TMAX,TMIN,PRCP)~DAY.OF.YEAR, data=davis.daily[davis.daily$YEAR %in% goodyears,], mean)
davis.yearvar<-data.frame(row.names=davis.yearnames) #dataframe to hold environmental variability
for (i in 1:length(davis.yearnames)){
#temporary dataframe to compare with mean conditions
#this creates a VAR.x for each year and a VAR.y for the daily means
comparison<-merge(davis.yearlist[[i]],davis.daily.means,by="DAY.OF.YEAR")
#number of complete cases (is.na=F) for each year
davis.yearvar[i,"TMAX.N"]<-sum(complete.cases(davis.yearlist[[i]]$TMAX))
davis.yearvar[i,"TMIN.N"]<-sum(complete.cases(davis.yearlist[[i]]$TMIN))
davis.yearvar[i,"PRCP.N"]<-sum(complete.cases(davis.yearlist[[i]]$PRCP))
#sum of squared differences with an average year - how weird is each year?
#some years have incomplete data, so this is the mean SS per observed day
davis.yearvar[i,"TMAX.SS"]<-(sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)^2)/davis.yearvar[i,"TMAX.N"]
davis.yearvar[i,"TMIN.SS"]<-(sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)^2)/davis.yearvar[i,"TMIN.N"]
davis.yearvar[i,"PRCP.SS"]<-(sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)^2)/davis.yearvar[i,"PRCP.N"]
#CV within years - how variable is each year?
davis.yearvar[i,"TMAX.CV"]<-sd(comparison$TMAX.x,na.rm=T)/mean(comparison$TMAX.x,na.rm=T)
davis.yearvar[i,"TMIN.CV"]<-sd(comparison$TMIN.x,na.rm=T)/mean(comparison$TMIN.x,na.rm=T)
davis.yearvar[i,"PRCP.CV"]<-sd(comparison$PRCP.x,na.rm=T)/mean(comparison$PRCP.x,na.rm=T)
#sum of differences (not squared) with an average year - how hot/wet is each year?
#some years have incomplete data, so this is the mean difference per observed day
davis.yearvar[i,"TMAX.DEL"]<-sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)/davis.yearvar[i,"TMAX.N"]
davis.yearvar[i,"TMIN.DEL"]<-sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)/davis.yearvar[i,"TMIN.N"]
davis.yearvar[i,"PRCP.DEL"]<-sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)/davis.yearvar[i,"PRCP.N"]
}
######################################################
# Import sequence of years - LOUIE'S STUFF GOES HERE #
######################################################
years.list=davis.yearlist #Replace this with code to grab a list of data frames. Each data frame is a year.
######################
# Fitness generation #
######################
#For now, daily incremental fitness will be found by multiplying two gaussian functions together:
#  one for temp, that's maximized at best.temp with sd tempsd
#  the other for precip that's maximized at best.precip with sd precipsd
# We will then normalize the results to vary from 0 to 1
for(i.year in 1:length(years.list)){
newyear=years.list[[i.year]]
newyear=newyear[,c("DAY.OF.YEAR","TMAX","PRCP")]
colnames(newyear)<-c("day","tmax","precip")
daily.fit=dnorm(newyear$tmax,mean=best.temp,sd=sd.temp)*dnorm(newyear$precip,mean=best.precip,sd=sd.precip)
daily.fit=(daily.fit-min(daily.fit))/(max(daily.fit)-min(daily.fit))
years.list[[i.year]]=cbind(newyear, fit.daily=daily.fit)
}
# Each year data frame has $day, $precip, $tmean, $tmax, $tmin
# This will be the same list for all configurations of years - this is essentially just our year database
years.index=c(1,2,3,4,5,6,7,8,9,10) # This is the list of which year.list data to use for each generation of the model
#######################
# initializing population
#######################
##intialize a population of N individuals
# Their min and max values are determined by the start$ parameters
b.const<-runif(n=N,min=start$constmin,max=start$constmax)
b.day<-runif(n=N,min=start$daymin,max=start$daymax)
b.temp<-runif(n=N,min=start$tempmin,max=start$tempmax)
b.precip<-runif(n=N,min=start$precipmin,max=start$precipmax)
newpop<-data.frame(b.const,b.day,b.temp,b.precip)
pop<-selection(newpop,duration,year=years.list[[1]],N)
## Run Simulation
pophistory=runSim(startpop=pop,years.list=years.list,
years.ind=years.index,N=N,duration=duration,
sds=sds,mutrate=mutrate,generations=length(years.index[-1]))
#we've already used year 1 in initiating the pop
plotting=FALSE
if(plotting){
windows()
hist(pophistory[[1]]$emerge,breaks=20)
windows()
hist(pophistory[[5]]$emerge,breaks=20)
windows()
hist(pophistory[[11]]$emerge,breaks=20)
}
pophistory[[1]]
pophistory[[1]]$Wp
sum(pophistory[[1]]$Wp)
years.list
years.list[[1]]
years.list[[1]]$fit.daily
plot(years.list[[1]]$fit.daily,type='l')
netfit=NULL
for(i.day in 1:365){net.fit=c(netfit,sum(years.list[[1]]$fit.daily[i.day:min(i.day+10,365)]))}
plot(netfit)
netfit
net.fit=NULL
for(i.day in 1:365){net.fit=c(net.fit,sum(years.list[[1]]$fit.daily[i.day:min(i.day+10,365)]))}
plot(net.fit,type="l")
net.fit=NULL
for(i.day in 1:365){net.fit=c(net.fit,sum(years.list[[2]]$fit.daily[i.day:min(i.day+10,365)]))}
plot(net.fit,type="l")
for(i.day in 1:365){net.fit=c(net.fit,sum(years.list[[5]]$fit.daily[i.day:min(i.day+10,365)]))}
net.fit=NULL
for(i.day in 1:365){net.fit=c(net.fit,sum(years.list[[5]]$fit.daily[i.day:min(i.day+10,365)]))}
plot(net.fit,type="l")
net.fit=NULL
for(i.day in 1:365){net.fit=c(net.fit,sum(years.list[[10]]$fit.daily[i.day:min(i.day+10,365)]))}
plot(net.fit,type="l")
pophistory[[5]]
pophistory[[5]]$emerge
net.fit=NULL
for(i.year in 1:10)
for(i.day in 1:365){net.fit=c(net.fit,sum(years.list[[10]]$fit.daily[i.day:min(i.day+10,365)]))}
plot(net.fit,type="l")
net.fit=NULL
# for(i.year in 1:10)
for(i.day in 1:365){net.fit=c(net.fit,sum(years.list[[10]]$fit.daily[i.day:min(i.day+10,365)]))}
plot(net.fit,type="l")
hist(pophistory[[1]]$emerge,breaks=360,add=TRUE)
#data input script
#reads climate data, truncates to 101 years, and imputes missing values
#clear all variables
rm(list=ls())
#libraries
library(timeDate)
library(Amelia)
library(parallel)
#Set appropriate working directory
if(Sys.getenv("USERNAME")=="Collin" || Sys.getenv("USERNAME")=="collin"){ #If it's collin
if(Sys.info()[1]=="Linux"){
setwd("/home/collin/Dropbox/Grad school/research projects/yang_cue")
}else{
setwd("C:\\Repos\\phenology-cues") #desktop
}
}else{
if(Sys.getenv("COMPUTERNAME")=="ENT-YANG01"){
setwd("C:\\Users\\lhyang.ent-yang01\\SkyDrive\\Phenology simulation\\phenology-cues")#desktop
}else{
setwd("C:\\Users\\louie\\Documents\\GitHub\\phenology-cues")} #SP4
}
#input data
davis.daily<-read.csv("davis-data/626713.csv", header=T, na.strings="-9999")
davis.daily$YEAR<-as.numeric(substr(davis.daily$DATE,1,4)) #simple field for year
davis.daily<-davis.daily[davis.daily$YEAR>1913 & davis.daily$YEAR<2015,] #truncates the data to 101 complete years between 1914 and 2014
davis.daily$PRCP<-davis.daily$PRCP/10 #precips are reported in tenths of mm
davis.daily$TMAX<-davis.daily$TMAX/10 #temps are reported in tenths of degree C
davis.daily$TMIN<-davis.daily$TMIN/10 #temps are reported in tenths of degree C
davis.daily$DATE2<-as.Date(as.character(davis.daily$DATE),format="%Y %m %d") #DATE2 is date formatted
davis.daily$JULIAN<-julian(davis.daily$DATE2,origin=as.Date("1913-12-31")) #1914-01-01 is day 1
davis.daily$MONTH<-as.numeric(substr(davis.daily$DATE,5,6)) #simple field for month
davis.daily$DAY<-as.numeric(substr(davis.daily$DATE,7,8)) #simple field for day
davis.daily<-davis.daily[,c("DATE2","JULIAN", "YEAR","MONTH","DAY","PRCP","TMAX","TMIN")] #simplified dataframe
#temporary plots checking that the data are mostly complete
plot(davis.daily$JULIAN,is.na(davis.daily$TMAX))
#however, there are 143 missing rows
missing.row.count<-max(davis.daily$JULIAN)-length(davis.daily$JULIAN)
#this is a list of the missing JULIAN days
missing.days<-which((seq(1:max(davis.daily$JULIAN)) %in% davis.daily$JULIAN)=="FALSE")
#create a empty dataframe with 143 rows
missing.days.df <- data.frame(matrix(ncol = 8, nrow = 143))  #this need to be generalized for any number of missing rows
#create matching column names
colnames(missing.days.df)<-colnames(davis.daily)
#fill in the missing Julian days
missing.days.df$JULIAN<-missing.days
missing.days.df$DATE2<-as.Date(origin=as.Date("1913-12-31"),missing.days.df$JULIAN)
missing.days.df$YEAR<-as.numeric(format(missing.days.df$DATE2, format="%Y"))
missing.days.df$MONTH<-as.numeric(format(missing.days.df$DATE2, format="%m"))
missing.days.df$DAY<-as.numeric(format(missing.days.df$DATE2, format="%d"))
#Combine the two dataframes
davis.daily.w.missing.days<-rbind(missing.days.df,davis.daily)
#sort by JULIAN
davis.daily.w.missing.days<-davis.daily.w.missing.days[order(davis.daily.w.missing.days$JULIAN),]
#this is just a shortcut to expedite - should be cleaned up?
davis.daily<-davis.daily.w.missing.days
davis.yearlist<-split(davis.daily,davis.daily$YEAR) #list of each year separated
davis.yearnames<-unique(davis.daily$YEAR) #gives a list of all the years in the data
#calculates the "day of year", i.e. Jan 1 is 1, and 12/31 is 365
#adds a DAY.OF.YEAR column to each dataframe in the year list
for (i in 1:length(davis.yearnames)){
davis.yearlist[[i]]$DAY.OF.YEAR<-julian(davis.yearlist[[i]]$DATE2, origin=as.Date(paste(davis.yearnames[i],"01","01",sep="-")))+1 #add +1 so that the first day of the year is 1, not zero.
}
davis.daily<-unsplit(davis.yearlist,davis.daily$YEAR)
davis.daily.means<-aggregate(cbind(TMAX,TMIN,PRCP)~DAY.OF.YEAR, data=davis.daily, mean)
davis.yearvar<-data.frame(row.names=davis.yearnames) #dataframe to hold environmental variability
for (i in 1:length(davis.yearnames)){
#temporary dataframe to compare with mean conditions
#this creates a VAR.x for each year and a VAR.y for the daily means
comparison<-merge(davis.yearlist[[i]],davis.daily.means,by="DAY.OF.YEAR")
#number of complete cases (is.na=F) for each year
davis.yearvar[i,"TMAX.N"]<-sum(complete.cases(davis.yearlist[[i]]$TMAX))
davis.yearvar[i,"TMIN.N"]<-sum(complete.cases(davis.yearlist[[i]]$TMIN))
davis.yearvar[i,"PRCP.N"]<-sum(complete.cases(davis.yearlist[[i]]$PRCP))
#sum of squared differences with an average year - how weird is each year?
#some years have incomplete data, so this is the mean SS per observed day
davis.yearvar[i,"TMAX.SS"]<-(sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)^2)/davis.yearvar[i,"TMAX.N"]
davis.yearvar[i,"TMIN.SS"]<-(sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)^2)/davis.yearvar[i,"TMIN.N"]
davis.yearvar[i,"PRCP.SS"]<-(sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)^2)/davis.yearvar[i,"PRCP.N"]
#CV within years - how variable is each year?
davis.yearvar[i,"TMAX.CV"]<-sd(comparison$TMAX.x,na.rm=T)/mean(comparison$TMAX.x,na.rm=T)
davis.yearvar[i,"TMIN.CV"]<-sd(comparison$TMIN.x,na.rm=T)/mean(comparison$TMIN.x,na.rm=T)
davis.yearvar[i,"PRCP.CV"]<-sd(comparison$PRCP.x,na.rm=T)/mean(comparison$PRCP.x,na.rm=T)
#sum of differences (not squared) with an average year - how hot/wet is each year?
#some years have incomplete data, so this is the mean difference per observed day
davis.yearvar[i,"TMAX.DEL"]<-sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)/davis.yearvar[i,"TMAX.N"]
davis.yearvar[i,"TMIN.DEL"]<-sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)/davis.yearvar[i,"TMIN.N"]
davis.yearvar[i,"PRCP.DEL"]<-sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)/davis.yearvar[i,"PRCP.N"]
}
#this is resource intensive - USE WITH CAUTION
#add argument parallel?
#deal with negative values with post-imputation transformation
#try fewer spline knots
a.out<-amelia(davis.daily,m=5,ts="DAY.OF.YEAR",cs="YEAR",idvars=c("DATE2","MONTH","DAY","JULIAN"),intercs=T,splinetime=6)
tscsPlot(a.out,var="TMAX",cs="1917")
tscsPlot(a.out,var="TMIN",cs="1917")
tscsPlot(a.out,var="PRCP",cs="1917")
tscsPlot(a.out,var="TMAX",cs="1922")
tscsPlot(a.out,var="TMIN",cs="1922")
tscsPlot(a.out,var="PRCP",cs="1922")
tscsPlot(a.out,var="TMAX",cs="1936")
tscsPlot(a.out,var="TMIN",cs="1936")
tscsPlot(a.out,var="PRCP",cs="1936")
plot(a.out,which.vars=6:8)
#this is resource intensive - USE WITH CAUTION
overimpute(a.out, var = "TMAX")
install.packages("Amelia")
#data input script
#reads climate data, truncates to 101 years, and imputes missing values
#clear all variables
rm(list=ls())
#libraries
library(timeDate)
library(Amelia)
library(parallel)
#Set appropriate working directory
if(Sys.getenv("USERNAME")=="Collin" || Sys.getenv("USERNAME")=="collin"){ #If it's collin
if(Sys.info()[1]=="Linux"){
setwd("/home/collin/Dropbox/Grad school/research projects/yang_cue")
}else{
setwd("C:\\Repos\\phenology-cues") #desktop
}
}else{
if(Sys.getenv("COMPUTERNAME")=="ENT-YANG01"){
setwd("C:\\Users\\lhyang.ent-yang01\\SkyDrive\\Phenology simulation\\phenology-cues")#desktop
}else{
setwd("C:\\Users\\louie\\Documents\\GitHub\\phenology-cues")} #SP4
}
#input data
davis.daily<-read.csv("davis-data/626713.csv", header=T, na.strings="-9999")
davis.daily$YEAR<-as.numeric(substr(davis.daily$DATE,1,4)) #simple field for year
davis.daily<-davis.daily[davis.daily$YEAR>1913 & davis.daily$YEAR<2015,] #truncates the data to 101 complete years between 1914 and 2014
davis.daily$PRCP<-davis.daily$PRCP/10 #precips are reported in tenths of mm
davis.daily$TMAX<-davis.daily$TMAX/10 #temps are reported in tenths of degree C
davis.daily$TMIN<-davis.daily$TMIN/10 #temps are reported in tenths of degree C
davis.daily$DATE2<-as.Date(as.character(davis.daily$DATE),format="%Y %m %d") #DATE2 is date formatted
davis.daily$JULIAN<-julian(davis.daily$DATE2,origin=as.Date("1913-12-31")) #1914-01-01 is day 1
davis.daily$MONTH<-as.numeric(substr(davis.daily$DATE,5,6)) #simple field for month
davis.daily$DAY<-as.numeric(substr(davis.daily$DATE,7,8)) #simple field for day
davis.daily<-davis.daily[,c("DATE2","JULIAN", "YEAR","MONTH","DAY","PRCP","TMAX","TMIN")] #simplified dataframe
#temporary plots checking that the data are mostly complete
plot(davis.daily$JULIAN,is.na(davis.daily$TMAX))
#however, there are 143 missing rows
missing.row.count<-max(davis.daily$JULIAN)-length(davis.daily$JULIAN)
#this is a list of the missing JULIAN days
missing.days<-which((seq(1:max(davis.daily$JULIAN)) %in% davis.daily$JULIAN)=="FALSE")
#create a empty dataframe with 143 rows
missing.days.df <- data.frame(matrix(ncol = 8, nrow = 143))  #this need to be generalized for any number of missing rows
#create matching column names
colnames(missing.days.df)<-colnames(davis.daily)
#fill in the missing Julian days
missing.days.df$JULIAN<-missing.days
missing.days.df$DATE2<-as.Date(origin=as.Date("1913-12-31"),missing.days.df$JULIAN)
missing.days.df$YEAR<-as.numeric(format(missing.days.df$DATE2, format="%Y"))
missing.days.df$MONTH<-as.numeric(format(missing.days.df$DATE2, format="%m"))
missing.days.df$DAY<-as.numeric(format(missing.days.df$DATE2, format="%d"))
#Combine the two dataframes
davis.daily.w.missing.days<-rbind(missing.days.df,davis.daily)
#sort by JULIAN
davis.daily.w.missing.days<-davis.daily.w.missing.days[order(davis.daily.w.missing.days$JULIAN),]
#this is just a shortcut to expedite - should be cleaned up?
davis.daily<-davis.daily.w.missing.days
davis.yearlist<-split(davis.daily,davis.daily$YEAR) #list of each year separated
davis.yearnames<-unique(davis.daily$YEAR) #gives a list of all the years in the data
#calculates the "day of year", i.e. Jan 1 is 1, and 12/31 is 365
#adds a DAY.OF.YEAR column to each dataframe in the year list
for (i in 1:length(davis.yearnames)){
davis.yearlist[[i]]$DAY.OF.YEAR<-julian(davis.yearlist[[i]]$DATE2, origin=as.Date(paste(davis.yearnames[i],"01","01",sep="-")))+1 #add +1 so that the first day of the year is 1, not zero.
}
davis.daily<-unsplit(davis.yearlist,davis.daily$YEAR)
davis.daily.means<-aggregate(cbind(TMAX,TMIN,PRCP)~DAY.OF.YEAR, data=davis.daily, mean)
davis.yearvar<-data.frame(row.names=davis.yearnames) #dataframe to hold environmental variability
for (i in 1:length(davis.yearnames)){
#temporary dataframe to compare with mean conditions
#this creates a VAR.x for each year and a VAR.y for the daily means
comparison<-merge(davis.yearlist[[i]],davis.daily.means,by="DAY.OF.YEAR")
#number of complete cases (is.na=F) for each year
davis.yearvar[i,"TMAX.N"]<-sum(complete.cases(davis.yearlist[[i]]$TMAX))
davis.yearvar[i,"TMIN.N"]<-sum(complete.cases(davis.yearlist[[i]]$TMIN))
davis.yearvar[i,"PRCP.N"]<-sum(complete.cases(davis.yearlist[[i]]$PRCP))
#sum of squared differences with an average year - how weird is each year?
#some years have incomplete data, so this is the mean SS per observed day
davis.yearvar[i,"TMAX.SS"]<-(sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)^2)/davis.yearvar[i,"TMAX.N"]
davis.yearvar[i,"TMIN.SS"]<-(sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)^2)/davis.yearvar[i,"TMIN.N"]
davis.yearvar[i,"PRCP.SS"]<-(sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)^2)/davis.yearvar[i,"PRCP.N"]
#CV within years - how variable is each year?
davis.yearvar[i,"TMAX.CV"]<-sd(comparison$TMAX.x,na.rm=T)/mean(comparison$TMAX.x,na.rm=T)
davis.yearvar[i,"TMIN.CV"]<-sd(comparison$TMIN.x,na.rm=T)/mean(comparison$TMIN.x,na.rm=T)
davis.yearvar[i,"PRCP.CV"]<-sd(comparison$PRCP.x,na.rm=T)/mean(comparison$PRCP.x,na.rm=T)
#sum of differences (not squared) with an average year - how hot/wet is each year?
#some years have incomplete data, so this is the mean difference per observed day
davis.yearvar[i,"TMAX.DEL"]<-sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)/davis.yearvar[i,"TMAX.N"]
davis.yearvar[i,"TMIN.DEL"]<-sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)/davis.yearvar[i,"TMIN.N"]
davis.yearvar[i,"PRCP.DEL"]<-sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)/davis.yearvar[i,"PRCP.N"]
}
#this is resource intensive - USE WITH CAUTION
#add argument parallel?
#deal with negative values with post-imputation transformation
#try fewer spline knots
a.out<-amelia(davis.daily,m=5,ts="DAY.OF.YEAR",cs="YEAR",idvars=c("DATE2","MONTH","DAY","JULIAN"),intercs=T,splinetime=6)
tscsPlot(a.out,var="TMAX",cs="1917")
tscsPlot(a.out,var="TMAX",cs="1917")
a.out
a.out[[1]]
head(a.out[[1]])
a.out$imputations
a.out$imp1
a.out[[1]]$imp1
head(a.out[[1]]$imp1)
?aggregate
a.out
temp=split(a.out)
?split
temp=unsplit(a.out)
heaed(a.out[[1]]$imp1)
head(a.out[[1]]$imp1)
temp=unsplit(a.out,f="JULIAN")
temp
temp$imp1
a.out[[1]]["imp1"]
years.list=list()
length(a.out)
dim(a.out[[1]]$imp1
)
dim(a.out[[1]]$imp1)
dim(a.out[[2]]$imp1)
dim(a.out$imp1)
dim(a.out[[1]]$imp1)
years.list=a.out["imp1"]
years.list[[1]]
head(years.list)
years.list=a.out["imp1"]
years.list=a.out$imp1
head(years.list)
years.list
years.list=a.out[[1]]$imp1
head(years.list)
years.list=split(years.temp,f="YEAR")
years.temp=a.out[[1]]$imp1
years.list=split(years.temp,f="YEAR")
years.list[[1]]
dim(years.list)
length(years.list)
head(years.list)
head(years.list)
years.list[1:5,]
dim(years.list)
length(years.list)
head(years.temp)
class(years.temp)
years.list=split(x=years.temp,f="YEAR")
class(years.list)
length(years.list)
turd=runif(6)
poo=rep(1:3,2)
poo
turd
test=data.frame((turd=turd,poo=poo))
test=data.frame(turd=turd,poo=poo)
data.frame
test
split(test,"poo"
)
split(test,"poo")
turdtemp=split(test,"poo")
turdtemp[[1]]
turdtemp[[2]]
turdtemp=split(test,test$poo)
turdtemp
years.list=split(x=years.temp,f=years.temp$YEARS)
years.temp
years.temp=a.out[[1]]$imp1
years.temp$YEARS
head(years.temp)
years.temp=a.out[[1]]$imp1
years.list=split(x=years.temp,f=years.temp$YEAR)
years.list[[1]]
#CURRENTLY IN THE "SLOW AND CORRECT" STAGE
#optimize AFTER we confirm it works
#clear all variables
rm(list=ls())
#libraries
library(timeDate)
library(Amelia)
#Set appropriate working directory
if(Sys.getenv("USERNAME")=="Collin" || Sys.getenv("USERNAME")=="collin"){ #If it's collin
if(Sys.info()[1]=="Linux"){
setwd("/home/collin/Dropbox/Grad school/research projects/yang_cue")
}else{
setwd("C:\\Repos\\phenology-cues") #desktop
}
}else{
if(Sys.getenv("COMPUTERNAME")=="ENT-YANG01"){
setwd("C:\\Users\\lhyang.ent-yang01\\SkyDrive\\Phenology simulation\\phenology-cues")#desktop
}else{
setwd("C:\\Users\\lhyang\\Skydrive\\Phenology simulation\\phenology-cues")} #laptop
}
#Load sources file(s)
source("windows_subs.R")
#########################
# Simulation parameters #
#########################
#generations has been removed. instead simulation runs for the number of years in years.index
runNumber=3
duration=10
best.temp=15; sd.temp=10; #The optimal temp and the sd for the temp-by-fitness curve (which is gaussian)
best.precip=55; sd.precip=30; #The optimal precip and the sd for the precip-by-fitness curve (which is gaussian)
N=40 #number of individuals
start<-data.frame(  #this represents the min and max values used when randomly assigning initial values to the population
constmin=0,constmax=3,
daymin=0,daymax=1,
tempmin=0,tempmax=5,
precipmin=0,precipmax=1)
sds<-data.frame( #standard deviations for trait mutations. Currently set so that variance = max initial trait value
const=sqrt(start$constmax),
day=sqrt(start$daymax),
temp=sqrt(start$tempmax),
precip=sqrt(start$precipmax))
mutrate<-data.frame( #probability of each trait mutating in an individual. Mutations are independent of one another
const=.1,
day=.1,
temp=.1,
precip=.1)
