}
dev.new(width=9,height=6)
par(mar=c(7,5,5,3))
for(i.vals in 1:num.plots){
fix.traits.values=fix.valmat[i.vals,] #values to be held constant, in same order as fix.traits (if there are multiple traits)
#####################################
fix.vals=matrix(fix.traits.values,nrow=pointdense^2,ncol=length(fix.traits.values),byrow=TRUE)
xtemp=seq(250,450,length=pointdense)
# xtemp=seq(1/10^10,maxcues[[plot.traits[1]]]*length(traits),length=pointdense)
x=rep(xtemp,pointdense)
ytemp=seq(60,140,length=pointdense)
# ytemp=seq(1/10^10,maxcues[[plot.traits[2]]]*length(traits),length=pointdense)
y=x*0
for(i in 1:length(ytemp)){
y[(1+(i-1)*pointdense):(i*pointdense)]=rep(ytemp[i],pointdense)
}
calc.traits=c(plot.traits,fix.traits)
calc.vals=cbind(x,y,fix.vals)
N=pointdense^2
b.day=b.temp=b.precip=b.cutemp=b.cuprecip=b.daysq=b.tempsq=b.precipsq=b.cutempsq=b.cuprecipsq=rep(0,N)
count=1
for(i.trait in calc.traits){
randnums=calc.vals[,count]
randnums[randnums==0]=1/(10^10)
curvals=randnums
curname=paste("b.",i.trait,sep="")
assign(curname,curvals)
count=count+1
}
newpop<-data.frame(b.day,b.temp,b.precip,b.cutemp,b.cuprecip,b.daysq,b.tempsq,b.precipsq,b.cutempsq,b.cuprecipsq)
yrfit=matrix(0,nrow=N,ncol=length(years.index))
for(i in 1:length(years.index)){
pop<-fitness(year=years.list[[years.index[i]]],newpop=newpop,duration=duration,traits=traits)
yrfit[,i]=pop$fit
}
geofit=apply(yrfit,1,function(x){-sum(log(x))})
z=matrix(geofit,pointdense,pointdense,byrow=TRUE)
contour(x=xtemp, y=ytemp,
z=z,
xlab=plot.traits[1],
ylab=plot.traits[2],
sub=paste(fix.traits,"set to",round(fix.traits.values),"\n"),
main=paste("Contour of", runsname,"\n small is good"),
cex.lab=1.6,cex.main=1.6,cex.sub=1.4)
#marking out infinities
inf.geo=which(is.infinite(z))
points(x[inf.geo],y[inf.geo],pch='.')
b.traits=sprintf("b.%s",plot.traits)
points(res.slow[,b.traits[1]],res.slow[,b.traits[2]],col='red')
#points(res.slow[,b.traits[1]][1],res.slow[,b.traits[2]][1],col='blue')
dev.print(pdf,paste(figpath,sprintf("/fix-%s-at-%04.0f.pdf",fix.traits,fix.traits.values),sep=""))
}
source("scripts/analytic_image.R")
source("scripts/analytic_image.R")
paste(fix.traits,"set to",round(fix.traits.values),"\n"),
b.traits
traits
plot.traits
plot.traits=c("day","precip")
source("scripts/analytic_image.R")
source("scripts/analytic_image.R")
require(graphics)
require(fields)
# The below is needed only if you don't run the parameter file
# pointdense=100
# num.plots=10
# plot.traits=c("day","temp") #traits to vary
# fix.traits=setdiff(traits, plot.traits)
fix.b=sprintf("b.%s",fix.traits)
figpath=paste("results/analytic/",runsname,sep="")
dir.create(figpath,showWarnings = FALSE)
if(length(fix.traits)>1){ #if there are more than one fixed traits
fix.max=apply(res.slow[,fix.b],2,max)
fix.min=apply(res.slow[,fix.b],2,min)
fix.valmat=apply(rbind(fix.min,fix.max),2,function(x){seq(x[1],x[2],length=num.plots)})
}else{
fix.valmat=t(t(seq(min(res.slow[,fix.b]),max(res.slow[,fix.b]),length=num.plots)))
}
dev.new(width=9,height=6)
par(mar=c(7,5,5,3))
par(mar=c(7,5,5,3))
for(i.vals in 1:num.plots){
fix.traits.values=fix.valmat[i.vals,] #values to be held constant, in same order as fix.traits (if there are multiple traits)
#####################################
fix.vals=matrix(fix.traits.values,nrow=pointdense^2,ncol=length(fix.traits.values),byrow=TRUE)
x=rep(seq(1/10^10,maxcues[[plot.traits[1]]]*length(traits),length=pointdense),pointdense)
ytemp=seq(1/10^10,maxcues[[plot.traits[2]]]*length(traits),length=pointdense)
y=x*0
for(i in 1:length(ytemp)){
y[(1+(i-1)*pointdense):(i*pointdense)]=rep(ytemp[i],pointdense)
}
calc.traits=c(plot.traits,fix.traits)
calc.vals=cbind(x,y,fix.vals)
N=pointdense^2
b.day=b.temp=b.precip=b.cutemp=b.cuprecip=b.daysq=b.tempsq=b.precipsq=b.cutempsq=b.cuprecipsq=rep(0,N)
count=1
for(i.trait in calc.traits){
randnums=calc.vals[,count]
randnums[randnums==0]=1/(10^10)
curvals=randnums
curname=paste("b.",i.trait,sep="")
assign(curname,curvals)
count=count+1
}
newpop<-data.frame(b.day,b.temp,b.precip,b.cutemp,b.cuprecip,b.daysq,b.tempsq,b.precipsq,b.cutempsq,b.cuprecipsq)
yrfit=matrix(0,nrow=N,ncol=length(years.index))
for(i in 1:length(years.index)){
pop<-fitness(year=years.list[[years.index[i]]],newpop=newpop,duration=duration,traits=traits)
yrfit[,i]=pop$fit
}
geofit=apply(yrfit,1,function(x){-sum(log(x))})
z=matrix(geofit,pointdense,pointdense,byrow=TRUE)
maxrange=40
#Take every value that's more than maxrange greater than the minimum value (including infinity)
#  and turn that into maxrange+minimum value+100
cutoff=maxrange+min(z)
z[z>cutoff]=cutoff
z[is.infinite(z)]=cutoff
image.plot(x=seq(1/10^10,maxcues[[plot.traits[1]]]*length(traits),length=pointdense),
y=ytemp,
z=z,
ylab=plot.traits[2],
xlab=plot.traits[1],
col=c(rep("transparent",.1),rev(heat.colors(n=1000,alpha=1))),
sub=paste(fix.traits,"set to",round(fix.traits.values)),
main=paste("Heatmap of", runsname,"\n small is good"),
cex.lab=1.6,cex.main=1.6,cex.sub=1.4
)
# marking out infinities
# inf.geo=which(is.infinite(geofit))
# points(x[inf.geo],y[inf.geo],pch='.')
b.traits=sprintf("b.%s",plot.traits)
points(res.slow[,b.traits[1]],res.slow[,b.traits[2]],col='black')
#points(res.slow[,b.traits[1]][1],res.slow[,b.traits[2]][1],col='blue')
dev.print(pdf,paste(figpath,sprintf("/heat-fix-%s-at-%04.0f.pdf",fix.traits,fix.traits.values),sep=""))
#Again but broader
maxrange=200
z=matrix(geofit,pointdense,pointdense,byrow=TRUE)
#Take every value that's more than maxrange greater than the minimum value (including infinity)
#  and turn that into maxrange+minimum value+100
cutoff=maxrange+min(z)
z[z>cutoff]=cutoff
z[is.infinite(z)]=cutoff
image.plot(x=seq(1/10^10,maxcues[[plot.traits[1]]]*length(traits),length=pointdense),
y=ytemp,
z=z,
ylab=plot.traits[2],
xlab=plot.traits[1],
col=c(rep("transparent",.1),rev(heat.colors(n=1000,alpha=1))),
sub=paste(fix.traits,"set to",round(fix.traits.values),"\n", collapse=" "),
main=paste("Heatmap of", runsname,"\n small is good"),
cex.lab=1.6,cex.main=1.6,cex.sub=1.4
)
# marking out infinities
# inf.geo=which(is.infinite(geofit))
# points(x[inf.geo],y[inf.geo],pch='.')
b.traits=sprintf("b.%s",plot.traits)
points(res.slow[,b.traits[1]],res.slow[,b.traits[2]],col='black')
#points(res.slow[,b.traits[1]][1],res.slow[,b.traits[2]][1],col='blue')
dev.print(pdf,paste(figpath,sprintf("/heat-fix-broad-%s-at-%04.0f.pdf",fix.traits,fix.traits.values),sep=""))
}
source("scripts/analytic_image.R")
require(vegan)
require(scatterplot3d)
setwd("results")
resultsdir=sprintf("%s/resRun%s",runsname,runName)
setwd(resultsdir)
#Make a matrix of daily fitnesses for all years, cutting out the last day of leap years
yearFit=matrix(0,nrow=length(years.index),ncol=365)
count=1
for(i in years.index){
curfits=years.list[[i]]$fit.daily
if(length(curfits)==366){curfits=curfits[-366]} #to handle leap years, remove last day
yearFit[count,]=curfits;
count=count+1
}
#Calculate the mean fitness accrued each day
par(mar=c(5,5,4,3))
meanFit=apply(yearFit,2,mean)
#calculate the mean fitness for emerging on day x (for all days) [this is using mean fitness accrued per day]
meanFitSum=rollapply(c(meanFit,rep(0,duration-1)),duration,by=1,sum)
for(i.day in 1:365){
meanFitSum=c(meanFitSum,sum(rep(meanFit)[i.day:(i.day+duration-1)]))
}
x11(width=9,height=6)
if(plotExtra==TRUE){
for(curgen in c(1:20,seq(21,length(years.index),length=10))){
curgen=round(curgen)
#arheight=rep(max(meanFit)*1.1,N) #upper bound used for making plots look good
emergeDay=pophistory[[curgen]]$emerge
#     plot(meanFit,type='l',ylim=c(0,max(meanFit)*1.2))
#     arrows(y0=jitter(arheight,factor=1.5),x0=emergeDay,x1=emergeDay+duration-1,length=.1)
#     dev.print(pdf,paste("dailyfit-run",runName,"-gen",curgen,"-meanfit.pdf",sep=""))
#     plot(meanFitSum,type='l',ylim=c(0,max(meanFitSum)*1.2),
#          main=paste("Mean fitness gained, gen",curgen),
#          ylab="Fitness gained",
#          xlab="Julian date",
#          cex.lab=1.3,
#          cex.main=1.3)
#     arheight=jitter(rep(max(meanFitSum)*1.05,N),factor=.8)
#     arrows(y0=arheight+.05*max(meanFitSum),x0=emergeDay,y1=arheight,length=.1)
#     dev.print(pdf,paste("dailyfitSum-run",runName,"-gen",curgen,"-meanfit.pdf",sep=""))
#now calculate the fitSum for THIS YEAR ONLY
FitSum=rollapply(c(years.list[[years.index[[curgen]]]]$fit.daily,rep(0,duration-1)),duration,by=1,sum)
plot(FitSum,type='l',ylim=c(0,max(FitSum)*1.2),
main=paste("Fitness gained this year, gen",curgen),
ylab="Fitness gained",
xlab="Julian date",
cex.lab=1.3,
cex.main=1.3)
arheight=jitter(rep(max(FitSum)*1.05,N),factor=.8)
arrows(y0=arheight+.05*max(FitSum),x0=emergeDay,y1=arheight,length=.1)
points(meanFitSum,type='l',lty=3)
dev.print(pdf,paste("dailyfitSum-run",runName,"-gen",curgen,"-actualfit.pdf",sep=""))
#Now plot each of the coefs by emergence day.
#     for(coefName in c("b.day","b.temp","b.precip")){
#       plot(pophistory[[curgen]][,coefName],pophistory[[curgen]][,"emerge"],
#            main=paste(coefName, "by emergence, gen", curgen),
#            ylab="emergence",
#            xlab=coefName,
#            cex.lab=1.3,
#            cex.main=1.3)
#       dev.print(pdf,paste("Coef_x_emerge-",coefName,"-run",runName,"-gen",curgen,".pdf",sep=""))
#     }
#     coefList=c("b.day","b.temp","b.precip")
#     for(i in 1:3){
#       coef1=coefList[i]
#       coef2=coefList[(i %% 3)+1]
#       curpop=pophistory[[curgen]]
#       plot(x=curpop[,coef1],y=curpop[,coef2],type='n',
#            main=paste(coef1, "by", coef2, "gen", curgen),
#            ylab=coef2,
#            xlab=coef1,
#            cex.lab=1.3,
#            cex.main=1.3)
#       points(x=(curpop[curpop[,"emerge"]>364,coef1]),y=(curpop[curpop[,"emerge"]>364,coef2]),pch=3,col='blue')
#       points(x=(curpop[curpop[,"emerge"]<365,coef1]),y=(curpop[curpop[,"emerge"]<365,coef2]),pch=1,col='black')
#       dev.print(pdf,paste("Coef_x_coef-",coef1,"x",coef2,"-run",runName,"-gen",curgen,".pdf",sep=""))
#     }
}
}
#Calculating changes in mean fitness through time
maxfit=maxActfit=meanfit=emerge.ideal=quant50=rep(0,length(years.index))
emerge=matrix(0,ncol=N,nrow=length(years.index))
for(curgen in 1:numYears){
meanfit[curgen]=mean(pophistory[[curgen]]$Wi)
maxActfit[curgen]=max(pophistory[[curgen]]$Wi)
cur.fitness=years.list[[years.index[curgen]]]$fit.daily
cur.fitness.durated=rollapply(c(cur.fitness,rep(0,duration-1)),duration,by=1,sum)
maxfit[curgen]=max(cur.fitness.durated)
emerge[curgen,]=pophistory[[curgen]]$emerge
emerge.ideal[curgen]=min(which(cur.fitness.durated==maxfit[curgen]))
quant50[curgen]=which(cumsum(cur.fitness.durated)/sum(cur.fitness.durated)>=.5)[1]
}
#plot emergence times
maxCount=100 #maximum number of years to count
generations=1:length(years.index)
viewGens=generations
if(length(generations)>maxCount){
viewGens=floor(seq(min(generations),max(generations),length.out=maxCount))
}
#Plot when organisms emerge
matplot(jitter(viewGens),emerge[viewGens,],type='p',pch=1,col='black',
main=paste("Emergence days"),
xlab="Generation",
ylab="Emergence day",
cex.lab=1.4,cex.main=1.4)
#add `optimal emergence day' - note this is a vast oversimplification
points(viewGens,emerge.ideal[viewGens],col="red",pch=4,lwd=2)
points(viewGens,quant50[viewGens],col="blue",pch=4,lwd=2)
dev.print(pdf,paste("emerge-run",runName,"-gen",curgen,".pdf",sep=""))
#plot mean fitness through time, showing max possible fitness
plot(maxfit,type='l',col='red',
main=paste("Mean fitness through time for run",runName),
xlab="generation",
ylab="Raw mean fitness",
sub="red is maximum possible",
ylim=c(0,max(maxfit))
)
points(1:length(meanfit),meanfit,type='l')
dev.print(pdf,paste("meanfit-run",runName,"-gen",curgen,".pdf",sep=""))
#plot mean fitness through time, normalized by max fitness
plot(meanfit/maxfit,type='l',col='black',
main=paste("Mean fitness / max possible",runName),
ylab="normalized mean fitness",
xlab="generation",
sub="red is maximum possible",
ylim=c(0,1)
)
abline(h=1,col='red')
dev.print(pdf,paste("meanfitNorm-run",runName,"-gen",curgen,".pdf",sep=""))
#plot max potential fitness and max actual fitness through time
#  ie the fittest individual of each generatoin
plot(maxfit,type='l',col='red',
main=paste("Max achieved fitness through time for run",runName),
xlab="generation",
ylab="Raw max fitness",
sub="red is maximum possible",
ylim=c(0,max(maxfit))
)
points(1:length(maxActfit),maxActfit,type='l')
dev.print(pdf,paste("maxfit-run",runName,"-gen",curgen,".pdf",sep=""))
#Looking at coef changes through time
#  The act.eff is the actual effect size, found by multiplying the coefficient of each indiv by the environmental conditions of their day of emergence.
#    Those plots use crosses to represent individuals who didn't emerge until the final day, and circles for those that emerged on a normal day (ie their cue
act.eff=actTraitEff(years.index,years.list,pophistory,N,traits)
act.vals=actTraitVals(pophistory,numYears,N)
traitslist=sprintf("b.%s",traits)
#x11(width=9,height=6)
par(mar=c(5,5,4,4))
#Plot it all in one
par(mfrow=c(3,1))
ind=1
while(ind<=length(traitslist)){
plotlist=ind:min(ind+2,length(traitslist))
for(cur.trait in plotlist){
emergePlot(indivs=act.eff,trait=traitslist[cur.trait])
}
dev.print(pdf,paste("coefEffects-",paste(traitslist[plotlist],collapse='-'),"-actual-run",runName,".pdf",sep=""))
for(cur.trait in plotlist){
emergePlotYlim(indivs=act.eff,trait=traitslist[cur.trait],ylim=c(0,100))
}
dev.print(pdf,paste("coefEffects-",paste(traitslist[plotlist],collapse='-'),"-actual-run-ylim",runName,".pdf",sep=""))
for(cur.trait in plotlist){
emergePlot(indivs=act.eff[act.eff[,"gen"]>burnIn,],trait=traitslist[cur.trait])
}
dev.print(pdf,paste("coefEffects-",paste(traitslist[plotlist],collapse='-'),"-actual-postburn-run",runName,".pdf",sep=""))
for(cur.trait in plotlist){
traitplot(indivs=act.vals,trait=traitslist[cur.trait])
}
dev.print(pdf,paste("coefVals-",paste(traitslist[plotlist],collapse='-'),"-run",runName,".pdf",sep=""))
for(cur.trait in plotlist){
traitplot(indivs=act.vals[act.vals[,"gen"]>burnIn,],trait=traitslist[cur.trait])
}
dev.print(pdf,paste("coefVals-",paste(traitslist[plotlist],collapse='-'),"-postburn-run",runName,".pdf",sep=""))
ind=max(plotlist)+1
}
#Plot phenotypes through time
par(mfrow=c(1,1))
pop.temp=do.call(rbind.data.frame,pophistory[c(seq(2,length(years.index),by=100))])
traitmins=NULL
for(i.trait in traitslist){traitmins=c(traitmins,min(pop.temp[,i.trait]))}
traitmaxs=NULL
for(i.trait in traitslist){traitmaxs=c(traitmaxs,max(pop.temp[,i.trait]))}
#x11(width=9,height=6)
if(plotPheno==TRUE){
traitslist=sprintf("b.%s",traits)
if(length(traitslist==1)){ #only one trait, do hist
hist(cur.pop[,traitslist])
}else if(length(traitslist==2)){
plot(cur.pop[,traitslist])
dev.print(pdf,sprintf("pheno-gen%06d-run%s.pdf",curgen,runName))
}
for(curgen in c(1,seq(2,numYears,length=20))){
curgen=round(curgen)
cur.pop=pophistory[[curgen]]
if(length(traitslist==1)){ #only one trait, do hist
hist(cur.pop[,traitslist])
}else if(length(traitslist==2)){
plot(cur.pop[,traitslist])
dev.print(pdf,sprintf("pheno-gen%06d-run%s.pdf",curgen,runName))
}
if(length(traitslist)==3){ #can just do 3d plot
scatterplot3d(jitter(as.matrix(cur.pop[,traitslist])),type='h',
xlim=c(traitmins[1],traitmaxs[1]),
ylim=c(traitmins[2],traitmaxs[2]),
zlim=c(traitmins[3],traitmaxs[3]))
dev.print(pdf,sprintf("pheno-gen%06d-run%s.pdf",curgen,runName))
}else{
cur.ndms=metaMDS(cur.pop[,traitslist],k=2,trymax=100,autotransform = TRUE)
plot(cur.ndms,main=paste("NDMS for generation", curgen))
dev.print(pdf,sprintf("pheno-gen%06d-run%s.pdf",curgen,runName))
}
}
}
# a few new plotting ideas ------------------------------------------------
library(reshape2)
library(ggplot2)
library(gridExtra)
#coeff.eff.sum<-aggregate(cbind(b.day,b.cutemp,b.cuprecip)~gen,data=act.eff,mean)
coeff.eff.sum<-aggregate(act.eff[,traitslist]~gen,data=act.eff,mean)
# coeff.vals.sum<-aggregate(cbind(b.day,b.temp,b.precip)~gen,data=act.vals,mean)
#to look at a smaller subset of the data, here up to 50 generations
#coeff.eff.sum<-coeff.eff.sum[coeff.eff.sum$gen<50,]
coeff.eff.sum.melt<- melt(coeff.eff.sum, id.var="gen")
p1<-ggplot(coeff.eff.sum.melt,aes(x=gen,y=value,fill=variable))+geom_smooth()
p2<-ggplot(coeff.eff.sum.melt,aes(x=gen,y=value,color=variable))+geom_line()+geom_point()+geom_smooth()
grid.arrange(p1,p2,ncol=1)
dev.print(pdf,sprintf("ggtraits.eff-run%s.pdf",curgen,runName))
#more 3D scatterplotting
# library(plot3D)
# library(plot3Drgl)
# x<-coeff.eff.sum$b.day
# y<-coeff.eff.sum$b.temp
# z<-coeff.eff.sum$b.precip
#
# fit<-lm(z~x+y)
# grid.lines = 26
# x.pred<-seq(min(x),max(x),length.out=grid.lines)
# y.pred<-seq(min(y),max(y),length.out=grid.lines)
# xy<-expand.grid(x=x.pred,y=y.pred)
# z.pred<-matrix(predict(fit,newdata = xy),nrow=grid.lines,ncol=grid.lines)
# fitpoints <- predict(fit)
#
# scatter3D(x,y,z,colvar=coeff.eff.sum$gen,type = "h", ticktype = "detailed", pch = 19,xlab="b.day.eff", ylab="b.temp.eff", zlab="b.precip.eff", clab="gen",surf = list(x = x.pred, y = y.pred, z = z.pred,facets = NA, fit = fitpoints))
#
# plotrgl()
?load
runsname
runsname.old=runsname
simcount=1
name.old=paste("resRun",runsname.old,simcount)
#need old runsname
load(paste("results/",runsname.old,"/",name.old,".Rdata"),envir=e<-new.env())
set_wrkdir()
load(paste("results/",runsname.old,"/",name.old,".Rdata"),envir=e<-new.env())
name.old=paste("resRun",runsname.old,simcount,sep="")
#need old runsname
load(paste("results/",runsname.old,"/",name.old,".Rdata"),envir=e<-new.env())
name.old=paste("resRun",runsname.old,simcount,sep="")
#need old runsname
load(paste("results/",runsname.old,"/",name.old,".Rdata",sep=""),envir=e<-new.env())
name.old=paste("resRun",runsname.old,simcount,sep="")
#need old runsname
load(paste("results/",runsname.old,"/",name.old,"/dat.Rdata",sep=""),envir=e<-new.env())
head([["pophistory"]])
head(e[["pophistory"]])
pop.old=e[["pophistory"]]
pop.old[[1]]
head(pop.old[[1]])
length(pop.old)
head(pop.old[[length(pop.old)]])
?ndms
?ndms
require(vegan)
require(scatterplot3d)
pop.old
yrs=do.call(rbind.data.frame,pop.old[1,100,200,300,400,500])
yrs=do.call(rbind.data.frame,pop.old[c(1,100,200,300,400,500)])
dim(yrs)
pop.old[[1]]
plotpop=do.call(rbind.data.frame,pop.old[c(1,100,200,300,400,500)])
community_matrix=matrix(
sample(1:100,300,replace=T),nrow=10,
dimnames=list(paste("community",1:10,sep=""),paste("sp",1:30,sep="")))
View(community_matrix
)
traitslist
head(plotpop)
cur.ndms=metaMDS(plotpop[,traitslist],k=2,trymax=100,autotransform = TRUE)
plotpop=do.call(rbind.data.frame,pop.old[c(100,500)])
plotpop=plotpop[c(1:100,1001:1100)]
plotpop=plotpop[c(1:100,1001:1100),]
cur.ndms=metaMDS(plotpop[,traitslist],k=2,trymax=100,autotransform = TRUE)
x11()
plot(cur.ndms)
cur.ndms=metaMDS(plotpop[,traitslist],k=2,trymax=100,autotransform = TRUE,labels=gen)
plot(cur.ndms)
stressplot(cur.ndms)
plot(cur.ndms,display="gen",col="blue")
require(dplyr)
install.packages("dplyr")
require(dplyr)
rename(plotpop, community=gen)
plotpop=rename(plotpop, community=gen)
cur.ndms=metaMDS(plotpop[,c("community",traitslist)],k=2,trymax=100,autotransform = TRUE,labels=gen)
cur.ndms=metaMDS(plotpop[,c("community",traitslist)],k=2,trymax=100,autotransform = TRUE)
plotpop=select(plotpop,community,get(traitslist))
head(plotpop)
traitslist
plotpop=select(plotpop,community,b.day,b.temp,b.precip)
plotpop=do.call(rbind.data.frame,pop.old[c(100,500)])
plotpop=plotpop[c(1:100,1001:1100),]
plotpop=rename(plotpop, community=gen)
plotpop=select(plotpop,community,b.day,b.temp,b.precip)
head(plotpop)
cur.ndms=metaMDS(plotpop,k=2,trymax=100,autotransform = TRUE)
cur.ndms=metaMDS(plotpop[,2:4],k=2,trymax=100,autotransform = TRUE)
cur.ndms=metaMDS(plotpop,k=2,trymax=100,autotransform = TRUE)
plot(cur.ndms,display="gen",col="blue")
plot(cur.ndms,display="copmmunity",col="blue")
plot(cur.ndms,display="community",col="blue")
plot(cur.ndms,display="sites",col="blue")
plot(cur.ndms)
dim(plotpop)
plotpop=plotpop[c(1:400,1001:1400),]
plotpop=do.call(rbind.data.frame,pop.old[c(100,500)])
plotpop=plotpop[c(1:400,1001:1400),]
plotpop=rename(plotpop, community=gen)
plotpop=select(plotpop,community,b.day,b.temp,b.precip)
cur.ndms=metaMDS(plotpop,k=2,trymax=100,autotransform = TRUE)
orditorp(cur.ndms,type="n")
orditorp(example_NMDS,display="sites",cex=1.25,air=0.01)
orditorp(cur.ndms,display="sites",cex=1.25,air=0.01)
orditorp(cur.ndms)
plot(cur.ndms)
ordilabel(cur.ndms)
ordilabel(cur.ndms,display="sites")
head(plotpop)
cur.ndms=metaMDS(plotpop,k=2,trymax=100,autotransform = TRUE,labels="community")
ordilabel(cur.ndms,display="sites")
ordilabel(cur.ndms)
plot(cur.ndms)
ordilabel(cur.ndms,display="community")
ordilabel(cur.ndms,display="species")
cur.ndms=metaMDS(plotpop[2:4],k=2,trymax=100,autotransform = TRUE,labels=plotpop$community)
plot(cur.ndms)
ordilabel(cur.ndms,display="species")
ordilabel(cur.ndms)
plot(cur.ndms)
ordilabel(cur.ndms)
orditorp(cur.ndms,display="sites",cex=1.25,air=0.01)
