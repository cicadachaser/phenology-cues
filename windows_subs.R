#Updated through "fitness" function


emergence<-function(year,indiv){
  #Indiv (individual) has four important attributes
  # $b.const, $b.day, $b.temp, $b.precip
  # calculating emergence value as E= b.const+b.day*day+b.temp*temp+b.precip*precip
  # Then finding the first day when the calculated E is greater than 100 (100 chosen for arbitrary convenience)
  temp.E=(indiv$b.const+indiv$b.day*year$day+indiv$b.temp*year$tmean+indiv$b.precip*year$precip)
  return(min(c(min(which(temp.E>100)),365)))
}

fitness<-function(year,individs,duration){ # fitness is the sum of W over the lifespan
  #FOR SIMPLICITY, ASSUMING END OF YEAR MEANS DEATH. CHANGE IF APPROPRIATE.
  #Function for giving fitness of individuals based on their start time, duration, and the W.
  #Inputs:
  #  year: data frame of climate and fitness information for current year
  #  individs: matrix of individuals, with each row corresponding to an individual, rows $b.const, $b.day, $b.temp, $b.precip
  #  duration: number of days organism is alive
  #Returns:
  #  res: vector of the fitnesses of each individual
  #
  fit=rep(0,length(indvids[,1]))
  for(i.indiv in 1:length(fit)){
    start=emergence(year,indiv=individs[i.indiv,])
    fit[i.indiv]=sum(year$fit.daily[start:min(c(start+duration-1,365))])
  }
  return(fit)
}

selection<-function(newpop,duration,W){
  #Function for carrying out `soft selection' - all individuals reproduce, with variable fitness.
  #Inputs:
  #  newpop: data frame with two columns (t.start and t.duration), and a row for every individual
  #  W: vector of goodness of environment, to pass to fitness() function
  #  duration: lifespan of organisms
  #Returns:
  #  newpop: a matrix with 5 columns - t.start, Wi, Ws, Wp, and Wnum
  #
  #newWi<-mapply(fitness,newpop$t.start,MoreArgs=list(duration=duration,W=W))
  newWi=fitness(t.start=newpop$t.start,duration=duration,W=W)
  newWs<-(newWi-min(newWi))/(max(newWi)-min(newWi)) #rescaled between 0 and 1, centered on the mid-range
  newWsurv<-newWs*(newWs>0) #newWsurv: all individuals survive (some may have zero fitness, none have neg fitness)
  newWp<-newWsurv/sum(newWsurv) #Wp is the proportional fitness after mortality
  #   newWnum<-round(N*newWp) #Wnum is the integer number of offspring for each individual, population maintained at N
  newWnum=(rmultinom(1,size=N,prob=newWp)) #To avoid potential rounding weirdness, had individuals assigned via the multinomial distribution
  newpop<-cbind(newpop,newWi,newWs,newWp,newWnum)
  colnames(newpop)<-c("t.start","Wi","Ws","Wp","Wnum")
  return(newpop)
}


#! Added tuning parameter
#! Made function take vectors, return a matrix of new start and new duration
mutation<-function(t.start,sd.start=0.5,sd.dur=0.5){
  #Function that creates random offspring with variable t.start and t.duration values
  #Inputs:
  #  t.start: vector of starting times, one for each individual
  #  sd.start: standard deviation for mutation of start time
  #  sd.dur: standard deviation for mutation of duration
  #Returns
  #  2-dimensional matrix of new starting times and new durations.
  #
  new.t.start<-t.start+round(rnorm(length(t.start),mean=0,sd=sd.start),1) #Gaussian random mutation; adjust sd for "mutation rate"
  #consider not rounding? The initial values aren't integers
  new.t.start<-new.t.start*(new.t.start>0) #return negative values to zero
  new.t.start<-((new.t.start-1) %% 12)+1 #wrapping t.start - using modulo operator for speed. It's a cool function, but gives zeros unless you offset with -1 and then +1
  #consider not rounding? The initial values aren't integers
  return(new.t.start)
}

reproduction<-function(pop){
  #Function for handling reproduction
  #Inputs:
  #  pop: population data frame generated by selection() function
  #Returns:
  #  Next generation as a data frame.
  repop<-pop[pop$Wnum>0,]
  expandpop<-data.frame(t.start=rep(0,N))
  ind=1
  for(i in 1:nrow(repop)){
    for (j in 1:repop$Wnum[i]) {
      expandpop[ind,]<-c(repop$t.start[i])
      ind=ind+1
    }
  }
  newpop = mutation(expandpop[,1]) #remove initial placeholder row
  t.start=newpop #to simplify naming - REMOVE WHEN POP HAS MORE THAN ONE COLUMN
  #colnames(newpop)<-c("t.start")
  return(data.frame(t.start))
}

#environmental variation function
envar<-function(y1,y2,month,y1.opt,y2.opt,sd=.5){
  #Function for adding noise to environment and generating a fine-grain resolution environmental `goodness' metric W
  #Inputs:
  #  y1: vector of monthly averages of temp
  #  y2: vector of monthly average precip
  #  y1.opt: optimal temp value
  #  y2.opt: optimal precip value
  #  sd:standard deviation defining the amount of variation between years, defaults to 0.5
  #Returns
  #  W: vector of immediate fitness-gains for all points in time.
  #
  newy1<-y1+rnorm(1,mean=0,sd=sd) 
  newy2<-y2+rnorm(1,mean=0,sd=sd)
  #! Some alternative ways to add variation: 
  #!   Can use sample() with a vector of probabilities to specify likelihood of 
  #!     various different increases/decreases (if want discrete variations).
  #!   Could have offset years, where monthly averages occur late or early
  model1<-loess(newy1~month, span=.35); #create model for smoothing the year across months
  xv1<-seq(0,12,0.0001)
  yv1<-predict(model1,data.frame(month=xv1))# create smooth year
  model2<-loess(newy2~month, span=.35);
  xv2<-seq(0,12,0.0001)
  yv2<-predict(model2,data.frame(month=xv2))
  W1r<-dnorm(yv1,mean=y1.opt,sd=y1.opt) #Fitness as a function of temp - distance from optimal temp over time.
  W1<-(W1r-min(W1r))/(max(W1r)-min(W1r)) #rescaled between 0 to 1
  W2r<-dnorm(yv2,mean=y2.opt,sd=y2.opt) #Fitness as a function of precip
  W2<-(W2r-min(W2r))/(max(W2r)-min(W2r)) #rescaled between 0 to 1
  Wr<-W1*W2 #raw fitness - multiply fitness by precip and temp
  W<-2*(Wr-mean(range(Wr)))/(max(Wr)-min(Wr)) #defining the combined fitness landscale, rescaled between -1 and 1 to prevent long-lived strategies
  return(W)
}


runSim<-function(pop,y1,y2,month,y1.opt,y2.opt,duration, generations=24,graphics=FALSE){
  #Function that actually runs the simulation (calling the other functions above)
  #Inputs:
  #  pop: initial population
  #  y1: baseline monthly mean temperatures
  #  y2: baseline monthly mean precip
  #  month: vector of months corresponding to y1, y2
  #  y1.opt: optimal temperature
  #  y2.opt: optimal precip
  #  generations: number of generations to simulate. Defaults to 24
  #  graphics: boolean, defaults to false. If true, carry out some plotting operations
  #Returns
  #  pophistory: list where each element represents the full population data frame for each generation
  #
  pophistory<-list(pop) #initialize the population history
  for(g in 1:generations){
    #reproduction
    newpop<-reproduction(pop)
    #inter-annual variation
    W<-envar(y1=y1,y2=y2,month=month,y1.opt=y1.opt,y2.opt=y2.opt)
    #selection
    newpop<-selection(newpop,duration,W)
    pophistory[[g+1]]<-newpop
    pop<-newpop   
  }
  return(pophistory)
}