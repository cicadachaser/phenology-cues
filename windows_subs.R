#Updated through "fitness" function


emergence<-function(year,indiv){
  #Function for calculating the emergence day of the given individual in the given year.
  #  Calculates emergence value as E= b.const+b.day*day+b.temp*temp+b.precip*precip
  # Then finds the first day when the calculated E is greater than 100 (100 chosen for arbitrary convenience)
  # Inputs:
  #  Indiv: (individual) has four important attributes: $b.const, $b.day, $b.temp, $b.precip
  #  year: current year data. Includes columns $day, $tmax, $precip
  # Output:
  #  day (Julian) of emergence
  E=(rep(indiv$b.const,length(year[,1]))+indiv$b.day*year$day+indiv$b.temp*year$tmax+indiv$b.precip*year$precip)
  return(min(c(min(which(E>100),365)))) #find the first day where emergence value is greater than 100 (or the last day of the year)
}

fitness<-function(year,newpop,duration){ 
  #Function for giving fitness of individuals based on their start time, duration, and the W.
  # fitness is the sum of W over the lifespan
  #FOR SIMPLICITY, ASSUMING END OF YEAR MEANS DEATH. CHANGE IF APPROPRIATE.
  #Inputs:
  #  year: data frame of climate and fitness information for current year. Includes $fit.daily column
  #  newpop: matrix of individuals, with each row corresponding to an individual, rows $b.const, $b.day, $b.temp, $b.precip
  #  duration: number of days organism is emerged
  #Returns:
  #  fit: vector of the fitnesses of each individual
  #
  fit=rep(0,length(newpop[,1]))
  evect=fit
  for(i.indiv in 1:length(fit)){
    start=emergence(year,indiv=newpop[i.indiv,])
    fit[i.indiv]=sum(year$fit.daily[start:min(c(start+duration-1,365))])
    evect[i.indiv]=start
  }
  return(data.frame(fit=fit,emerge=evect))
}

selection<-function(newpop,duration,year,N){
  #Function for carrying out `soft selection' - all individuals reproduce, with variable fitness.
  #Inputs:
  #  newpop: data frame with the current population trait values; each row is an individual
  #  year: data on the year, including a column for daily fitness
  #  duration: lifespan of organisms
  #  N: number of individuals in the population
  #Returns:
  #  newpop: a matrix with the current population traits, plus raw fitness (Wi),
  #     rescaled fitness(Ws), proportional fitness after mortality(Wp), and number of offspring (Wnum)
  #
  out=fitness(year=year,newpop=newpop,duration=duration)
  newWi=out$fit
  newWs<-(newWi-min(newWi))/(max(newWi)-min(newWi)+.0001) #rescaled between 0 and 1, centered on the mid-range
  newWsurv<-newWs*(newWs>0) #newWsurv: all individuals survive (some may have zero fitness, none have neg fitness)
    #That line should be unneccessary, since I don't think we can end up with negative fitness under current schema
  newWp<-newWsurv/(sum(newWsurv)+.0001)+.00001 #Wp is the proportional fitness after mortality
  newWnum=(rmultinom(1,size=N,prob=newWp)) #To avoid potential rounding weirdness, had individuals assigned via the multinomial distribution
  init.colnames=colnames(newpop)
  newpop<-cbind(newpop,out$emerge,newWi,newWs,newWp,newWnum)
  colnames(newpop)<-c(init.colnames,"emerge","Wi","Ws","Wp","Wnum")
  return(newpop)
}



mutation<-function(poptraits,sds,mutrate,N){
  #Function that creates random offspring with variable t.start and t.duration values
  #Inputs:
  #  poptraits: a matrix of just the traits for the current population
  #  sds: 1-d data frame of standard deviations for mutations of the various traits. Has values $const, $day, $temp, $precip
  #  mutrate: 1-d data frame for PROBABILITY of mutation for each of the traits. Has values $const, $day, $temp, $precip
  #Returns
  #  2-dimensional matrix of the new (post-mutation) traits of the population
  #
  mat.runif=matrix(runif(length(sds[1,])*N),nrow=N, ncol=length(sds[1,])) #generate matrix of random uniform numbers for testing
  test.mutate=cbind(seq(mutrate$const,N),seq(mutrate$day,N),seq(mutrate$temp,N),seq(mutrate$precip,N)) #THESE NEED TO BE IN THE SAME ORDER AS THE POPULATIONS
  mat.mutate=mat.runif<test.mutate # which traits of which individuals mutated?
  vals.mutate=cbind(rnorm(n=N,mean=0,sd=sds$const),rnorm(n=N,mean=0,sd=sds$day),
                    rnorm(n=N,mean=0,sd=sds$temp),rnorm(n=N,mean=0,sd=sds$precip))# Generate random mutations for all traits of all individuals. THESE NEED TO BE IN THE SAME ORDER AS THE POPULATIONS
  poptraits=poptraits+mat.mutate*vals.mutate #Take current population, add mutations only for individuals and traits that mutated.  
  return(poptraits)
}

reproduction<-function(pop){
  #THIS FUNCTION CAN PROBABLY BE MADE MUCH FASTER
  #Function for handling reproduction
  #Inputs:
  #  pop: population data frame generated by selection() function. Includes Wnum
  #Returns:
  #  Next generation as a data frame.
  repop<-pop[pop$Wnum>0,]
  expandpop<-data.frame(b.const=rep(0,N),b.day=rep(0,N),b.temp=rep(0,N),b.precip=rep(0,N))
  ind=1
  for(i in 1:nrow(repop)){
    for (j in 1:repop$Wnum[i]) {
      expandpop[ind,]<-c(repop$b.const[i],repop$b.day[i],repop$b.temp[i],repop$b.precip[i])
      ind=ind+1
    }
  }
  return(expandpop)
}

runSim<-function(startpop,years.list,years.ind,N,duration,sds,mutrate,generations,graphics=FALSE){
  #Function that actually runs the simulation (calling the other functions above)
  #Inputs:
  #  startpop: initial population
  #  years.list: List of dataframes for daily information on each year (MUST INCLUDE DAILY FITNESS)
  #  years.ind: vector of indices for the year to use for each generation. 
  #  N: number of individuals in the population
  #  duration: number of days all individuals is in an emerged state
  #  sds: standard deviation for the distribution of mutation sizes for each trait
  #  mutrate: probability of mutation for each trait (per individual).
  #  generations: number of generations to simulate.
  #  graphics: boolean, defaults to false. If true, carry out some plotting operations
  #Returns
  #  pophistory: list where each element represents the full population data frame for each generation
  #
  pop=startpop
  pophistory<-list(cbind(startpop, gen=rep(1,N))) #initialize the population history
  for(g in 1:generations){
    #reproduction
    cur.year=years.list[[years.ind[g]]]
    newpop<-reproduction(pop)
    newpop<-mutation(newpop,sds,mutrate,N)
    newpop<-selection(newpop,duration,cur.year,N)
    pophistory[[g+1]]<-cbind(newpop, gen=rep(g+1,N))
    pop<-newpop
  }
  return(pophistory)
}