{
    "contents" : "#Updated through \"fitness\" function\n\n\nemergence<-function(year,indiv){\n  #Function for calculating the emergence day of the given individual in the given year.\n  #  Calculates emergence value as E= b.const+b.day*day+b.temp*temp+b.precip*precip\n  # Then finds the first day when the calculated E is greater than 100 (100 chosen for arbitrary convenience)\n  # Inputs:\n  #  Indiv: (individual) has four important attributes: $b.const, $b.day, $b.temp, $b.precip\n  #  year: current year data. Includes columns $day, $tmax, $precip\n  # Output:\n  #  day (Julian) of emergence\n  E=(rep(indiv$b.const,length(year[,1]))+indiv$b.day*year$day+indiv$b.temp*year$tmax+indiv$b.precip*year$precip)\n  return(min(c(min(which(E>100),365)))) #find the first day where emergence value is greater than 100 (or the last day of the year)\n}\n\nfitness<-function(year,newpop,duration){ \n  #Function for giving fitness of individuals based on their start time, duration, and the W.\n  # fitness is the sum of W over the lifespan\n  #FOR SIMPLICITY, ASSUMING END OF YEAR MEANS DEATH. CHANGE IF APPROPRIATE.\n  #Inputs:\n  #  year: data frame of climate and fitness information for current year. Includes $fit.daily column\n  #  newpop: matrix of individuals, with each row corresponding to an individual, rows $b.const, $b.day, $b.temp, $b.precip\n  #  duration: number of days organism is emerged\n  #Returns:\n  #  fit: vector of the fitnesses of each individual\n  #\n  fit=rep(0,length(newpop[,1]))\n  evect=fit\n  for(i.indiv in 1:length(fit)){\n    start=emergence(year,indiv=newpop[i.indiv,])\n    fit[i.indiv]=sum(year$fit.daily[start:min(c(start+duration-1,365))])\n    evect[i.indiv]=start\n  }\n  return(data.frame(fit=fit,emerge=evect))\n}\n\nselection<-function(newpop,duration,year,N){\n  #Function for carrying out `soft selection' - all individuals reproduce, with variable fitness.\n  #Inputs:\n  #  newpop: data frame with the current population trait values; each row is an individual\n  #  year: data on the year, including a column for daily fitness\n  #  duration: lifespan of organisms\n  #  N: number of individuals in the population\n  #Returns:\n  #  newpop: a matrix with the current population traits, plus raw fitness (Wi),\n  #     rescaled fitness(Ws), proportional fitness after mortality(Wp), and number of offspring (Wnum)\n  #\n  print(newpop)\n  out=fitness(year=year,newpop=newpop,duration=duration)\n  print(out)\n  newWi=out$fit\n  newWs<-(newWi-min(newWi))/(max(newWi)-min(newWi)+.0001) #rescaled between 0 and 1, centered on the mid-range\n  newWsurv<-newWs*(newWs>0) #newWsurv: all individuals survive (some may have zero fitness, none have neg fitness)\n    #That line should be unneccessary, since I don't think we can end up with negative fitness under current schema\n  newWp<-newWsurv/(sum(newWsurv)+.0001)+.00001 #Wp is the proportional fitness after mortality\n  newWnum=(rmultinom(1,size=N,prob=newWp)) #To avoid potential rounding weirdness, had individuals assigned via the multinomial distribution\n  init.colnames=colnames(newpop)\n  newpop<-cbind(newpop,out$emerge,newWi,newWs,newWp,newWnum)\n  colnames(newpop)<-c(init.colnames,\"emerge\",\"Wi\",\"Ws\",\"Wp\",\"Wnum\")\n  return(newpop)\n}\n\n\n\nmutation<-function(poptraits,sds,mutrate,N){\n  #Function that creates random offspring with variable t.start and t.duration values\n  #Inputs:\n  #  poptraits: a matrix of just the traits for the current population\n  #  sds: 1-d data frame of standard deviations for mutations of the various traits. Has values $const, $day, $temp, $precip\n  #  mutrate: 1-d data frame for PROBABILITY of mutation for each of the traits. Has values $const, $day, $temp, $precip\n  #Returns\n  #  2-dimensional matrix of the new (post-mutation) traits of the population\n  #\n  mat.runif=matrix(runif(length(sds[1,])*N),nrow=N, ncol=length(sds[1,])) #generate matrix of random uniform numbers for testing\n  test.mutate=cbind(seq(mutrate$const,N),seq(mutrate$day,N),seq(mutrate$temp,N),seq(mutrate$precip,N)) #THESE NEED TO BE IN THE SAME ORDER AS THE POPULATIONS\n  mat.mutate=mat.runif<test.mutate # which traits of which individuals mutated?\n  vals.mutate=cbind(rnorm(n=N,mean=0,sd=sds$const),rnorm(n=N,mean=0,sd=sds$day),\n                    rnorm(n=N,mean=0,sd=sds$temp),rnorm(n=N,mean=0,sd=sds$precip))# Generate random mutations for all traits of all individuals. THESE NEED TO BE IN THE SAME ORDER AS THE POPULATIONS\n  poptraits=poptraits+mat.mutate*vals.mutate #Take current population, add mutations only for individuals and traits that mutated.  \n  return(poptraits)\n}\n\nreproduction<-function(pop){\n  #THIS FUNCTION CAN PROBABLY BE MADE MUCH FASTER\n  #Function for handling reproduction\n  #Inputs:\n  #  pop: population data frame generated by selection() function. Includes Wnum\n  #Returns:\n  #  Next generation as a data frame.\n  repop<-pop[pop$Wnum>0,]\n  expandpop<-data.frame(b.const=rep(0,N),b.day=rep(0,N),b.temp=rep(0,N),b.precip=rep(0,N))\n  ind=1\n  for(i in 1:nrow(repop)){\n    for (j in 1:repop$Wnum[i]) {\n      expandpop[ind,]<-c(repop$b.const[i],repop$b.day[i],repop$b.temp[i],repop$b.precip[i])\n      ind=ind+1\n    }\n  }\n  return(expandpop)\n}\n\nrunSim<-function(startpop,years.list,years.ind,N,duration,sds,mutrate,generations,graphics=FALSE){\n  #Function that actually runs the simulation (calling the other functions above)\n  #Inputs:\n  #  startpop: initial population\n  #  years.list: List of dataframes for daily information on each year (MUST INCLUDE DAILY FITNESS)\n  #  years.ind: vector of indices for the year to use for each generation. \n  #  N: number of individuals in the population\n  #  duration: number of days all individuals is in an emerged state\n  #  sds: standard deviation for the distribution of mutation sizes for each trait\n  #  mutrate: probability of mutation for each trait (per individual).\n  #  generations: number of generations to simulate.\n  #  graphics: boolean, defaults to false. If true, carry out some plotting operations\n  #Returns\n  #  pophistory: list where each element represents the full population data frame for each generation\n  #\n  pop=startpop\n  pophistory<-list(startpop) #initialize the population history\n  for(g in 1:generations){\n    #reproduction\n    cur.year=years.list[[years.ind[g]]]\n    newpop<-reproduction(pop)\n    newpop<-mutation(newpop,sds,mutrate,N)\n    newpop<-selection(newpop,duration,cur.year,N)\n    pophistory[[g+1]]<-newpop\n    pop<-newpop\n  }\n  return(pophistory)\n}",
    "created" : 1444947400832.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2843713659",
    "id" : "431E676C",
    "lastKnownWriteTime" : 1447966937,
    "path" : "C:/Users/lhyang.ent-yang01/SkyDrive/Phenology simulation/phenology-cues/windows_subs.R",
    "project_path" : "windows_subs.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}