{
    "contents" : "#CURRENTLY IN THE \"SLOW AND CORRECT\" STAGE\n#optimize AFTER we confirm it works\n\n#clear all variables\nrm(list=ls())\n\n#libraries\nlibrary(timeDate)\nlibrary(Cairo) #I'm not sure if we need this with the plotting removed\n\n#Set appropriate working directory\nif(Sys.getenv(\"USERNAME\")==\"Collin\" || Sys.getenv(\"USERNAME\")==\"collin\"){ #If it's collin\n  if(Sys.info()[1]==\"Linux\"){\n    setwd(\"/home/collin/Dropbox/Grad school/research projects/yang_cue\")\n  }else{\n    setwd(\"C:\\\\Repos\\\\phenology-cues\") #desktop\n  }\n}else{\n  if(Sys.getenv(\"COMPUTERNAME\")==\"ENT-YANG01\"){\n    setwd(\"C:\\\\Users\\\\lhyang.ent-yang01\\\\SkyDrive\\\\Phenology simulation\\\\phenology-cues\")#desktop\n  }else{  \n    setwd(\"C:\\\\Users\\\\lhyang\\\\Skydrive\\\\Phenology simulation\\\\phenology-cues\")} #laptop\n}\n#Load sources file(s)\nsource(\"windows_subs.R\")\n\n#########################\n# Simulation parameters #\n#########################\n#generations has been removed. instead simulation runs for the number of years in years.index\nduration=10\nbest.temp=15; sd.temp=10; #The optimal temp and the sd for the temp-by-fitness curve (which is gaussian)\nbest.precip=55; sd.precip=30; #The optimal precip and the sd for the precip-by-fitness curve (which is gaussian)\nN=40 #number of individuals \nstart<-data.frame(  #this represents the min and max values used when randomly assigning initial values to the population \n  constmin=0,constmax=5,\n  daymin=0,daymax=2,\n  tempmin=0,tempmax=10,\n  precipmin=0,precipmax=2) \nsds<-data.frame( #standard deviations for trait mutations. Currently set so that variance = max initial trait value\n  const=sqrt(start$constmax),\n  day=sqrt(start$daymax),\n  temp=sqrt(start$tempmax),\n  precip=sqrt(start$precipmax))\nmutrate<-data.frame( #probability of each trait mutating in an individual. Mutations are independent of one another\n  const=.1,\n  day=.1,\n  temp=.1,\n  precip=.1)\n\n#input data\ndavis.daily<-read.csv(\"davis-data/626713.csv\", header=T, na.strings=\"-9999\")\ndavis.daily$PRCP<-davis.daily$PRCP/10 #precips are reported in tenths of mm\ndavis.daily$TMAX<-davis.daily$TMAX/10 #temps are reported in tenths of degree C\ndavis.daily$TMIN<-davis.daily$TMIN/10 #temps are reported in tenths of degree C\ndavis.daily$DATE2<-as.Date(as.character(davis.daily$DATE),format=\"%Y %m %d\") #DATE2 is date formatted\ndavis.daily$JULIAN<-julian(davis.daily$DATE2,origin=as.Date(\"1892-12-31\")) #1893-01-01 is day 1...\ndavis.daily$YEAR<-as.numeric(substr(davis.daily$DATE,1,4)) #simple field for year\ndavis.daily$MONTH<-as.numeric(substr(davis.daily$DATE,5,6)) #simple field for month\ndavis.daily$DAY<-as.numeric(substr(davis.daily$DATE,7,8)) #simple field for day\ndavis.daily<-davis.daily[,c(\"DATE2\",\"JULIAN\", \"YEAR\",\"MONTH\",\"DAY\",\"PRCP\",\"TMAX\",\"TMIN\")] #simplified dataframe\n\ndavis.yearlist<-split(davis.daily,davis.daily$YEAR) #list of each year separated\n#calculates the \"day of year\", i.e. Jan 1 is 1, and 12/31 is 365 \n#adds a DAY.OF.YEAR column to each dataframe in the year list\ndavis.yearnames<-unique(davis.daily$YEAR)\nfor (i in 1:length(davis.yearnames)){\n  davis.yearlist[[i]]$DAY.OF.YEAR<-julian(davis.yearlist[[i]]$DATE2, origin=as.Date(paste(davis.yearnames[i],\"01\",\"01\",sep=\"-\")))+1 #add +1 so that the first day of the year is 1, not zero. \n}\nyearlist.store=davis.yearlist\ngoodyears=NULL\n\nfor(iyear in davis.yearnames){\n  nacount=sum(sum(is.na(davis.yearlist[[as.character(iyear)]])))\n  daycount=dim(davis.yearlist[[as.character(iyear)]])[1]\n  if(nacount==0 & daycount>364){goodyears=c(goodyears,iyear)}\n}\ndavis.yearlist=davis.yearlist[as.character(goodyears)]\n\ndavis.yearnames<-goodyears #gives a list of all the years in the data\n\n\n\n\ndavis.daily<-unsplit(yearlist.store,davis.daily$YEAR) #using legacy \"yearlist.store\" to make unsplit happy\n# DAY.OF.YEAR=rep(0,dim(davis.daily)[1])\n# for(i in 1:length(DAY.OF.YEAR)){\n#   DAY.OF.YEAR[i]=sprintf(\"%02d%02d\",davis.daily[i,\"MONTH\"],davis.daily[i,\"DAY\"])\n#   \n# }\n\n# davis.daily=cbind(davis.daily, DAY.OF.YEAR)\n\n# davis.daily<-unsplit(davis.daily,davis.daily$YEAR)\ndavis.daily.means<-aggregate(cbind(TMAX,TMIN,PRCP)~DAY.OF.YEAR, data=davis.daily[davis.daily$YEAR %in% goodyears,], mean)\n\ndavis.yearvar<-data.frame(row.names=davis.yearnames) #dataframe to hold environmental variability\n\nfor (i in 1:length(davis.yearnames)){\n  #temporary dataframe to compare with mean conditions\n  #this creates a VAR.x for each year and a VAR.y for the daily means\n  comparison<-merge(davis.yearlist[[i]],davis.daily.means,by=\"DAY.OF.YEAR\") \n  #number of complete cases (is.na=F) for each year\n  davis.yearvar[i,\"TMAX.N\"]<-sum(complete.cases(davis.yearlist[[i]]$TMAX))\n  davis.yearvar[i,\"TMIN.N\"]<-sum(complete.cases(davis.yearlist[[i]]$TMIN))\n  davis.yearvar[i,\"PRCP.N\"]<-sum(complete.cases(davis.yearlist[[i]]$PRCP))\n  #sum of squared differences with an average year - how weird is each year?\n  #some years have incomplete data, so this is the mean SS per observed day\n  davis.yearvar[i,\"TMAX.SS\"]<-(sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)^2)/davis.yearvar[i,\"TMAX.N\"]\n  davis.yearvar[i,\"TMIN.SS\"]<-(sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)^2)/davis.yearvar[i,\"TMIN.N\"]\n  davis.yearvar[i,\"PRCP.SS\"]<-(sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)^2)/davis.yearvar[i,\"PRCP.N\"]\n  #CV within years - how variable is each year?\n  davis.yearvar[i,\"TMAX.CV\"]<-sd(comparison$TMAX.x,na.rm=T)/mean(comparison$TMAX.x,na.rm=T)\n  davis.yearvar[i,\"TMIN.CV\"]<-sd(comparison$TMIN.x,na.rm=T)/mean(comparison$TMIN.x,na.rm=T)\n  davis.yearvar[i,\"PRCP.CV\"]<-sd(comparison$PRCP.x,na.rm=T)/mean(comparison$PRCP.x,na.rm=T)\n  #sum of differences (not squared) with an average year - how hot/wet is each year?\n  #some years have incomplete data, so this is the mean difference per observed day\n  davis.yearvar[i,\"TMAX.DEL\"]<-sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)/davis.yearvar[i,\"TMAX.N\"]\n  davis.yearvar[i,\"TMIN.DEL\"]<-sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)/davis.yearvar[i,\"TMIN.N\"]\n  davis.yearvar[i,\"PRCP.DEL\"]<-sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)/davis.yearvar[i,\"PRCP.N\"]\n}\n\n######################################################\n# Import sequence of years - LOUIE'S STUFF GOES HERE #\n######################################################\nyears.list=davis.yearlist #Replace this with code to grab a list of data frames. Each data frame is a year.\n######################\n# Fitness generation #\n######################\n#For now, daily incremental fitness will be found by multiplying two gaussian functions together:\n#  one for temp, that's maximized at best.temp with sd tempsd\n#  the other for precip that's maximized at best.precip with sd precipsd\n# We will then normalize the results to vary from 0 to 1\nfor(i.year in 1:length(years.list)){\n  newyear=years.list[[i.year]]\n  newyear=newyear[,c(\"DAY.OF.YEAR\",\"TMAX\",\"PRCP\")]\n  colnames(newyear)<-c(\"day\",\"tmax\",\"precip\")\n  daily.fit=dnorm(newyear$tmax,mean=best.temp,sd=sd.temp)*dnorm(newyear$precip,mean=best.precip,sd=sd.precip)\n  daily.fit=(daily.fit-min(daily.fit))/(max(daily.fit)-min(daily.fit))\n  years.list[[i.year]]=cbind(newyear, fit.daily=daily.fit)\n}\n\n\n# Each year data frame has $day, $precip, $tmean, $tmax, $tmin\n# This will be the same list for all configurations of years - this is essentially just our year database\nyears.index=c(1,2,3,4,5,6,7,8,9,10) # This is the list of which year.list data to use for each generation of the model\n\n\n\n\n\n#######################\n# initializing population\n#######################\n##intialize a population of N individuals\n# Their min and max values are determined by the start$ parameters\nb.const<-runif(n=N,min=start$constmin,max=start$constmax)\nb.day<-runif(n=N,min=start$daymin,max=start$daymax)\nb.temp<-runif(n=N,min=start$tempmin,max=start$tempmax)\nb.precip<-runif(n=N,min=start$precipmin,max=start$precipmax)\nnewpop<-data.frame(b.const,b.day,b.temp,b.precip)\npop<-selection(newpop,duration,year=years.list[[1]],N)\n\n## Run Simulation\npophistory=runSim(startpop=pop,years.list=years.list,\n                  years.ind=years.index,N=N,duration=duration,\n                  sds=sds,mutrate=mutrate,generations=length(years.index[-1]))\n#we've already used year 1 in initiating the pop\n\nplotting=FALSE\nif(plotting){\n  windows()\n  hist(pophistory[[1]]$emerge,breaks=20)\n  windows()\n  hist(pophistory[[5]]$emerge,breaks=20)\n  windows()\n  hist(pophistory[[11]]$emerge,breaks=20)\n}",
    "created" : 1444944028071.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1796780969",
    "id" : "68ADB89C",
    "lastKnownWriteTime" : 1447966937,
    "path" : "C:/Users/lhyang.ent-yang01/SkyDrive/Phenology simulation/phenology-cues/windows_main.R",
    "project_path" : "windows_main.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}