{
    "contents" : "#depreciated windows_main - do not merge with main\n#core data_input functions moved to data_input.R\n\n#START imputation script\n#clear all variables\nrm(list=ls())\n\n#libraries\nlibrary(timeDate)\nlibrary(Amelia)\n\n#Set appropriate working directory\nif(Sys.getenv(\"USERNAME\")==\"Collin\" || Sys.getenv(\"USERNAME\")==\"collin\"){ #If it's collin\n  if(Sys.info()[1]==\"Linux\"){\n    setwd(\"/home/collin/Dropbox/Grad school/research projects/yang_cue\")\n  }else{\n    setwd(\"C:\\\\Repos\\\\phenology-cues\") #desktop\n  }\n}else{\n  if(Sys.getenv(\"COMPUTERNAME\")==\"ENT-YANG01\"){\n    setwd(\"C:\\\\Users\\\\lhyang.ent-yang01\\\\SkyDrive\\\\Phenology simulation\\\\phenology-cues\")#desktop\n  }else{  \n    setwd(\"C:\\\\Users\\\\lhyang\\\\Skydrive\\\\Phenology simulation\\\\phenology-cues\")} #laptop\n}\n#Load sources file(s)\nsource(\"windows_subs.R\")\n\n#########################\n# Simulation parameters #\n#########################\n#generations has been removed. instead simulation runs for the number of years in years.index\nrunNumber=3\nduration=10\nbest.temp=15; sd.temp=10; #The optimal temp and the sd for the temp-by-fitness curve (which is gaussian)\nbest.precip=55; sd.precip=30; #The optimal precip and the sd for the precip-by-fitness curve (which is gaussian)\nN=40 #number of individuals \nstart<-data.frame(  #this represents the min and max values used when randomly assigning initial values to the population \n  constmin=0,constmax=3,\n  daymin=0,daymax=1,\n  tempmin=0,tempmax=5,\n  precipmin=0,precipmax=1) \nsds<-data.frame( #standard deviations for trait mutations. Currently set so that variance = max initial trait value\n  const=sqrt(start$constmax),\n  day=sqrt(start$daymax),\n  temp=sqrt(start$tempmax),\n  precip=sqrt(start$precipmax))\nmutrate<-data.frame( #probability of each trait mutating in an individual. Mutations are independent of one another\n  const=.1,\n  day=.1,\n  temp=.1,\n  precip=.1)\n\n#input data\ndavis.daily<-read.csv(\"davis-data/626713.csv\", header=T, na.strings=\"-9999\")\ndavis.daily$YEAR<-as.numeric(substr(davis.daily$DATE,1,4)) #simple field for year\ndavis.daily<-davis.daily[davis.daily$YEAR>1913 & davis.daily$YEAR<2015,] #truncates the data to 101 complete years between 1914 and 2014\n\ndavis.daily$PRCP<-davis.daily$PRCP/10 #precips are reported in tenths of mm\ndavis.daily$TMAX<-davis.daily$TMAX/10 #temps are reported in tenths of degree C\ndavis.daily$TMIN<-davis.daily$TMIN/10 #temps are reported in tenths of degree C\ndavis.daily$DATE2<-as.Date(as.character(davis.daily$DATE),format=\"%Y %m %d\") #DATE2 is date formatted\ndavis.daily$JULIAN<-julian(davis.daily$DATE2,origin=as.Date(\"1913-12-31\")) #1914-01-01 is day 1\ndavis.daily$MONTH<-as.numeric(substr(davis.daily$DATE,5,6)) #simple field for month\ndavis.daily$DAY<-as.numeric(substr(davis.daily$DATE,7,8)) #simple field for day\ndavis.daily<-davis.daily[,c(\"DATE2\",\"JULIAN\", \"YEAR\",\"MONTH\",\"DAY\",\"PRCP\",\"TMAX\",\"TMIN\")] #simplified dataframe\n\ndavis.yearlist<-split(davis.daily,davis.daily$YEAR) #list of each year separated\n\ndavis.yearnames<-unique(davis.daily$YEAR) #gives a list of all the years in the data\n\n#calculates the \"day of year\", i.e. Jan 1 is 1, and 12/31 is 365 \n#adds a DAY.OF.YEAR column to each dataframe in the year list\nfor (i in 1:length(davis.yearnames)){\n  davis.yearlist[[i]]$DAY.OF.YEAR<-julian(davis.yearlist[[i]]$DATE2, origin=as.Date(paste(davis.yearnames[i],\"01\",\"01\",sep=\"-\")))+1 #add +1 so that the first day of the year is 1, not zero. \n}\n\ndavis.daily<-unsplit(davis.yearlist,davis.daily$YEAR)\ndavis.daily.means<-aggregate(cbind(TMAX,TMIN,PRCP)~DAY.OF.YEAR, data=davis.daily, mean)\n\ndavis.yearvar<-data.frame(row.names=davis.yearnames) #dataframe to hold environmental variability\n\nfor (i in 1:length(davis.yearnames)){\n  #temporary dataframe to compare with mean conditions\n  #this creates a VAR.x for each year and a VAR.y for the daily means\n  comparison<-merge(davis.yearlist[[i]],davis.daily.means,by=\"DAY.OF.YEAR\") \n  #number of complete cases (is.na=F) for each year\n  davis.yearvar[i,\"TMAX.N\"]<-sum(complete.cases(davis.yearlist[[i]]$TMAX))\n  davis.yearvar[i,\"TMIN.N\"]<-sum(complete.cases(davis.yearlist[[i]]$TMIN))\n  davis.yearvar[i,\"PRCP.N\"]<-sum(complete.cases(davis.yearlist[[i]]$PRCP))\n  #sum of squared differences with an average year - how weird is each year?\n  #some years have incomplete data, so this is the mean SS per observed day\n  davis.yearvar[i,\"TMAX.SS\"]<-(sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)^2)/davis.yearvar[i,\"TMAX.N\"]\n  davis.yearvar[i,\"TMIN.SS\"]<-(sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)^2)/davis.yearvar[i,\"TMIN.N\"]\n  davis.yearvar[i,\"PRCP.SS\"]<-(sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)^2)/davis.yearvar[i,\"PRCP.N\"]\n  #CV within years - how variable is each year?\n  davis.yearvar[i,\"TMAX.CV\"]<-sd(comparison$TMAX.x,na.rm=T)/mean(comparison$TMAX.x,na.rm=T)\n  davis.yearvar[i,\"TMIN.CV\"]<-sd(comparison$TMIN.x,na.rm=T)/mean(comparison$TMIN.x,na.rm=T)\n  davis.yearvar[i,\"PRCP.CV\"]<-sd(comparison$PRCP.x,na.rm=T)/mean(comparison$PRCP.x,na.rm=T)\n  #sum of differences (not squared) with an average year - how hot/wet is each year?\n  #some years have incomplete data, so this is the mean difference per observed day\n  davis.yearvar[i,\"TMAX.DEL\"]<-sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)/davis.yearvar[i,\"TMAX.N\"]\n  davis.yearvar[i,\"TMIN.DEL\"]<-sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)/davis.yearvar[i,\"TMIN.N\"]\n  davis.yearvar[i,\"PRCP.DEL\"]<-sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)/davis.yearvar[i,\"PRCP.N\"]\n}\n\n#temporary plots checking that the data are mostly complete\nplot(davis.daily$JULIAN,davis.daily$TMAX) \nplot(davis.daily$JULIAN,is.na(davis.daily$TMAX))\n#however, there are 143 missing rows\nmax(davis.daily$JULIAN)-length(davis.daily$JULIAN)\nplot(match(seq(1:max(davis.daily$JULIAN)),davis.daily$JULIAN,nomatch=0))\n\n#amelia scripting in progress\n#amelia(davis.daily)\n\n# END IMPUTATION BRANCH REVISIONS\n\n######################################################\n# Import sequence of years - LOUIE'S STUFF GOES HERE #\n######################################################\nyears.list=davis.yearlist #Replace this with code to grab a list of data frames. Each data frame is a year.\n######################\n# Fitness generation #\n######################\n#For now, daily incremental fitness will be found by multiplying two gaussian functions together:\n#  one for temp, that's maximized at best.temp with sd tempsd\n#  the other for precip that's maximized at best.precip with sd precipsd\n# We will then normalize the results to vary from 0 to 1\nfor(i.year in 1:length(years.list)){\n  newyear=years.list[[i.year]]\n  newyear=newyear[,c(\"DAY.OF.YEAR\",\"TMAX\",\"PRCP\")]\n  colnames(newyear)<-c(\"day\",\"tmax\",\"precip\")\n  daily.fit=dnorm(newyear$tmax,mean=best.temp,sd=sd.temp)*dnorm(newyear$precip,mean=best.precip,sd=sd.precip)\n  daily.fit=(daily.fit-min(daily.fit))/(max(daily.fit)-min(daily.fit))\n  years.list[[i.year]]=cbind(newyear, fit.daily=daily.fit)\n}\n\n\n# Each year data frame has $day, $precip, $tmean, $tmax, $tmin\n# This will be the same list for all configurations of years - this is essentially just our year database\nyears.index=rep(c(1,2,3,4,5,6,7,8,9,10),10) # This is the list of which year.list data to use for each generation of the model\n\n\n\n\n\n#######################\n# initializing population\n#######################\n##intialize a population of N individuals\n# Their min and max values are determined by the start$ parameters\nb.const<-runif(n=N,min=start$constmin,max=start$constmax)\nb.day<-runif(n=N,min=start$daymin,max=start$daymax)\nb.temp<-runif(n=N,min=start$tempmin,max=start$tempmax)\nb.precip<-runif(n=N,min=start$precipmin,max=start$precipmax)\nnewpop<-data.frame(b.const,b.day,b.temp,b.precip)\npop<-selection(newpop,duration,year=years.list[[1]],N)\n\n## Run Simulation\npophistory=runSim(startpop=pop,years.list=years.list,\n                  years.ind=years.index,N=N,duration=duration,\n                  sds=sds,mutrate=mutrate,generations=length(years.index[-1]))\n#we've already used year 1 in initiating the pop\n\n###################################\n#Saving our results\n###################################\n#Turn results from list to data frame\npophist.table <-do.call(rbind.data.frame, pophistory)\n\n\n#handle folder making and moving\n#Set appropriate working directory\nif(Sys.getenv(\"USERNAME\")==\"Collin\" || Sys.getenv(\"USERNAME\")==\"collin\"){ #If it's collin\n  if(Sys.info()[1]==\"Linux\"){\n    setwd(\"/home/collin/Dropbox/Grad school/research projects/yang_cue\")\n  }else{\n    setwd(\"C:\\\\Repos\\\\phenology-cues\") #desktop\n  }\n}else{\n  if(Sys.getenv(\"COMPUTERNAME\")==\"ENT-YANG01\"){\n    setwd(\"C:\\\\Users\\\\lhyang.ent-yang01\\\\SkyDrive\\\\Phenology simulation\\\\phenology-cues\")#desktop\n  }else{  \n    setwd(\"C:\\\\Users\\\\lhyang\\\\Skydrive\\\\Phenology simulation\\\\phenology-cues\")} #laptop\n}\nsetwd(\"results\")\nresultsdir=sprintf(\"resRun%d\",runNumber)\ndir.create(resultsdir,showWarnings = FALSE)\nsetwd(resultsdir)\nwrite.table(pophist.table,file=paste(\"pophist_run\",runNumber,\".csv\",sep=\"\"),sep=\",\")\nparnames=c(\n  \"b.const\",\n  \"b.day\",\n  \"b.precip\",\n  \"b.temp\",\n  \"bestprecip\",\n  \"best.temp\",\n  \"duration\",\n  \"N\",\n  \"sd.precip\",\n  \"sd.temp\"\n)\nparvals=get(parnames)\nmeta=sprintf(\"%s has value %f\",parnames,parvals)\nsink(paste(\"par_values_run\",runNumber,\".txt\",sep=\"\"))\ncat(\"Parameters for simulation. Weather from davis data. \\n\")\nfor(i in meta){cat(paste(i,\"\\n\"))}\ncat(\" sds= \\n\")\nprint(sds)\ncat(\"\\n mutrate=\\n\")\nprint(mutrate)\ncat(\"\\n start=\\n\")\nprint(start)\ncat(\"\\n goodyears=\\n\")\nprint(goodyears)\ncat(\"\\n years.index=\\n\")\nprint(years.index)\nsink()\n\nsave(list=c(\"pophistory\",\"years.list\",\"years.index\"),file=\"dat.RData\")\n\n\n##############################\n# Plotting\n##############################\n\nyearFit=NULL\nfor(i in years.index){\n  curfits=years.list[[i]]$fit.daily\n  if(length(curfits)==366){curfits=curfits[-366]} #to handle leap years, remove least useful day\n  yearFit=rbind(yearFit,curfits)\n}\npar(mar=c(5,5,4,3))\nmeanFit=apply(yearFit,2,mean)\nmeanFitSum=NULL\nfor(i.day in 1:365){\n  meanFitSum=c(meanFitSum,sum(rep(meanFit,2)[i.day:(i.day+duration)]))\n}\n\n# par(mfrow=c(1,1))\nx11(width=9,height=6)\nfor(curgen in seq(2,length(years.index),length=5)){\n  #arheight=pophistory[[length(curgen)]]$Wi\n  curgen=round(curgen)\n  arheight=rep(max(meanFit)*1.1,N)\n  emergeDay=pophistory[[curgen]]$emerge\n  plot(meanFit,type='l',ylim=c(0,max(meanFit)*1.2))\n  # plot(1,1,type='n',ylim=c(0,max(arheight)*1.05),xlim=c(0,365))\n  arrows(y0=jitter(arheight,factor=1.5),x0=emergeDay,x1=emergeDay+duration,length=.1)\n  dev.print(pdf,paste(\"dailyfit-run\",runNumber,\"-gen\",curgen,\".pdf\",sep=\"\"))\n  \n  plot(meanFitSum,type='l',ylim=c(0,max(meanFitSum)*1.2),\n       main=paste(\"Mean fitness gained, gen\",curgen),\n       ylab=\"Fitness gained\",\n       xlab=\"Julian date\",\n       cex.lab=1.3,\n       cex.main=1.3)\n  arheight=rep(max(meanFitSum)*1.1,N)\n  arrows(y0=jitter(arheight,factor=1.5),x0=emergeDay,x1=emergeDay+duration,length=.1)\n  dev.print(pdf,paste(\"dailyfitSum-run\",runNumber,\"-gen\",curgen,\".pdf\",sep=\"\"))\n}\n# plotting=FALSE\n# if(plotting){\n#   windows()\n#   hist(pophistory[[1]]$emerge,breaks=20)\n#   windows()\n#   hist(pophistory[[5]]$emerge,breaks=20)\n#   windows()\n#   hist(pophistory[[11]]$emerge,breaks=20)\n# }\n# \n# net.fit=NULL\n# # for(i.year in 1:10)\n# for(i.day in 1:365){net.fit=c(net.fit,sum(years.list[[10]]$fit.daily[i.day:min(i.day+10,365)]))}\n# plot(net.fit,type=\"l\")\n# hist(pophistory[[1]]$emerge,breaks=360,add=TRUE)\n",
    "created" : 1449178990859.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1149038720",
    "id" : "21A73530",
    "lastKnownWriteTime" : 1449255598,
    "path" : "C:/Users/lhyang/SkyDrive/Phenology simulation/phenology-cues/windows_main.R",
    "project_path" : "windows_main.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}