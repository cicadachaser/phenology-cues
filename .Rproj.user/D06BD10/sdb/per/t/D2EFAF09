{
    "collab_server" : "",
    "contents" : "#Updated through \"fitness\" function\n\nemerge_sub<-function(x){min(c(which(x),366))} #function for use in \"apply\" within emergence()\n\nemergence<-function(year,newpop){\n  #Function for calculating the emergence day of the given individual in the given year.\n  #  Calculates emergence value as E= b.day*day+b.temp*temp+b.precip*precip\n  # Then finds the first day when the calculated E is greater than 100 (100 chosen for arbitrary convenience)\n  # Inputs:\n  #  Indiv: (individual) has three important attributes: $b.day, $b.temp, $b.precip\n  #  year: current year data. Includes columns $day, $tmax, $precip\n  # Output:\n  #  day (Julian) of emergence\n  E=newpop$b.day %*% t(year$day) + newpop$b.temp %*% t(year$temp) + newpop$b.precip %*% t(year$precip) +\n    newpop$b.cutemp %*% t(year$cutemp) + newpop$b.cuprecip %*% t(year$cuprecip) +\n    newpop$b.daysq %*% t(year$daysq) + newpop$b.tempsq %*% t(year$tempsq) + newpop$b.precipsq %*% t(year$precipsq) +\n    newpop$b.cutempsq %*% (t(year$cutempsq)^2) + newpop$b.cuprecipsq %*% t(year$cuprecipsq)\n  emerge=apply(E>100,1,emerge_sub)\n  return(emerge) #find the first day where emergence value is greater than 100 (or the last day of the year)\n}\nfitness<-function(year,newpop,duration){\n  #Function for giving fitness of individuals based on their start time, duration, and the W.\n  # fitness is the sum of W over the lifespan\n  #FOR SIMPLICITY, ASSUMING END OF YEAR MEANS DEATH. CHANGE IF APPROPRIATE.\n  #Inputs:\n  #  year: data frame of climate and fitness information for current year. Includes $fit.daily column\n  #  newpop: matrix of individuals, with each row corresponding to an individual, rows $b.const, $b.day, $b.temp, $b.precip\n  #  duration: number of days organism is emerged\n  #Returns:\n  #  fit: vector of the fitnesses of each individual\n  #\n  evect=emergence(year=year,newpop=newpop)\n  #Create a vector with the \"total fitness you experience if you emerge on this day\" values.\n  # (using rollapply function from \"zoo\" library to make this fast)\n  # Adding a 0 at the end of the vector: if you didn't emerge in the normal year, you \"emerge\" on day 366 which has zero fitness. ie if you don't emerge you die.\n  fitVals=c(rollapply(c(year$fit.daily,rep(0,duration-1)),duration,by=1,sum),0)\n  fit=fitVals[evect]\n  return(data.frame(fit=fit,emerge=evect))\n}\n\nselection<-function(newpop,duration,year,N){\n  #Function for carrying out `soft selection' - all individuals reproduce, with variable fitness.\n  #Inputs:\n  #  newpop: data frame with the current population trait values; each row is an individual\n  #  year: data on the year, including a column for daily fitness\n  #  duration: lifespan of organisms\n  #  N: number of individuals in the population\n  #Returns:\n  #  newpop: a matrix with the current population traits, plus raw fitness (Wi),\n  #     rescaled fitness(Ws), proportional fitness after mortality(Wp), and number of offspring (Wnum)\n  #\n  out=fitness(year=year,newpop=newpop,duration=duration)\n  newWi=out$fit\n  newWnum=(rmultinom(1,size=N,prob=newWi)) #To avoid potential rounding weirdness, had individuals assigned via the multinomial distribution\n  init.colnames=colnames(newpop)\n  newpop<-cbind(newpop,out$emerge,newWi,newWnum)\n  colnames(newpop)<-c(init.colnames,\"emerge\",\"Wi\",\"Wnum\")\n  return(newpop)\n}\n\nmutation<-function(poptraits,sds,mutrate,N){\n  #Function that creates random offspring with variable t.start and t.duration values\n  #Inputs:\n  #  poptraits: a matrix of just the traits for the current population\n  #  sds: 1-d data frame of standard deviations for mutations of the various traits. Has values $const, $day, $temp, $precip\n  #  mutrate: 1-d data frame for PROBABILITY of mutation for each of the traits. Has values $const, $day, $temp, $precip\n  #Returns\n  #  2-dimensional matrix of the new (post-mutation) traits of the population\n  #\n  mat.runif=matrix(runif(length(sds)*N),nrow=N, ncol=length(sds)) #generate matrix of random uniform numbers for testing\n  #make a data frame with N rows, each row being a duplicate of the mutrate list\n  mutframe=data.frame(t(unlist(mutrate))) #one row\n  test.mutate=mutframe[rep(1,N),] #sneaky way to make N rows\n  mat.mutate=mat.runif<test.mutate # which traits of which individuals mutated?\n  #This is a little dicey, but when executed correctly (like here), allows me to make our entire rnorm matrix in one shot.\n  #It relies on the INCREDIBLY STUPID FACT that R recycles vectors when needed. I don't like it, but the code works and is quick.\n  vals.mutate=matrix(rnorm(n=N*length(sds),mean=0,sd=unlist(sds)),N,length(sds),byrow=TRUE)\n  colnames(vals.mutate)<-sprintf(\"b.%s\",names(sds))\n  poptraits=poptraits+mat.mutate*vals.mutate #Take current population, add mutations only for individuals and traits that mutated.\n  return(poptraits)\n}\n\nreproduction<-function(pop){\n  #THIS FUNCTION CAN PROBABLY BE MADE MUCH FASTER\n  #Function for handling reproduction\n  #Inputs:\n  #  pop: population data frame generated by selection() function. Includes Wnum\n  #Returns:\n  #  Next generation as a data frame.\n  repop<-pop[pop$Wnum>0,]\n  nameslist=sprintf(\"b.%s\",names(sds))\n  expandpop<-data.frame(t(rep(0,length(sds))))[rep(1,N),]\n  colnames(expandpop)<-nameslist\n  ind=1\n  for(i in 1:nrow(repop)){\n    for (j in 1:repop$Wnum[i]) {\n      expandpop[ind,]<-repop[i,!names(repop) %in% c(\"emerge\",\"Wi\",\"Wnum\")]\n      ind=ind+1\n    }\n  }\n  return(expandpop)\n}\nrunSim<-function(startpop,years.list,years.index,N,duration,sds,mutrate,generations,graphics=FALSE){\n  #Function that actually runs the simulation (calling the other functions above)\n  #Inputs:\n  #  startpop: initial population\n  #  years.list: List of dataframes for daily information on each year (MUST INCLUDE DAILY FITNESS)\n  #  years.ind: vector of indices for the year to use for each generation.\n  #  N: number of individuals in the population\n  #  duration: number of days all individuals is in an emerged state\n  #  sds: standard deviation for the distribution of mutation sizes for each trait\n  #  mutrate: probability of mutation for each trait (per individual).\n  #  generations: number of generations to simulate.\n  #  graphics: boolean, defaults to false. If true, carry out some plotting operations\n  #Returns\n  #  pophistory: list where each element represents the full population data frame for each generation\n  #\n  pop=startpop\n  pophistory<-list(cbind(startpop, gen=rep(1,N))) #initialize the population history\n  for(g in 1:generations){\n    #reproduction\n    cur.year=years.list[[years.index[g]]]\n    newpop<-reproduction(pop=pop)\n    newpop<-mutation(poptraits=newpop,sds=sds,mutrate=mutrate,N=N)\n    newpop<-selection(newpop=newpop,duration=duration,year=cur.year,N=N)\n    pophistory[[g+1]]<-cbind(newpop, gen=rep(g+1,N))\n    pop<-newpop\n  }\n  return(pophistory)\n}\n\n######################\n# Analysis Functions #\n######################\n\n#####\nactTraitVals<-function(pophistory,numYears,N){\n  coef.indiv=matrix(data=0,ncol=6,nrow=N*numYears,\n                    dimnames = list(NULL,c(\"gen\",\"b.day\",\"b.temp\",\"b.precip\",\"relfit\",\"emerge\")))\n  index=1\n  for(i.gen in 1:numYears){\n    curhist=pophistory[[i.gen]]\n    coef.indiv[index:(index+N-1),\"gen\"]=rep(i.gen,N)\n    coef.indiv[index:(index+N-1),\"relfit\"]=curhist$Wi\n    coef.indiv[index:(index+N-1),\"emerge\"]=curhist$emerge\n    coef.indiv[index:(index+N-1),\"b.day\"]=curhist$b.day\n    coef.indiv[index:(index+N-1),\"b.temp\"]=curhist$b.temp\n    coef.indiv[index:(index+N-1),\"b.precip\"]=curhist$b.precip\n    index=index+N\n  }\n  return(coef.indiv)\n}\n\nactTraitEff<-function(years.index,years.list,pophistory,N){\n  #  Function for calculating the actual effect size of each coefficient for each indiv\n  #    This is done by finding the conditions when each individual emerged, and calculating the effect of each coefficient on that day.\n  #  Inputs:\n  coef.indiv=matrix(data=0,ncol=6,nrow=N*length(years.index),\n                    dimnames = list(NULL,c(\"gen\",\"b.day\",\"b.temp\",\"b.precip\",\"relfit\",\"emerge\")))\n  index=1\n  for(i.gen in 1:length(years.index)){\n    curhist=pophistory[[i.gen]] #store the current year of population date\n    curyear=years.list[[years.index[[i.gen]]]] #store the current year of envi conditions\n    coef.indiv[index:(index+N-1),\"gen\"]=rep(i.gen,N)\n    coef.indiv[index:(index+N-1),\"relfit\"]=curhist$Wi\n    coef.indiv[index:(index+N-1),\"emerge\"]=curhist$emerge\n    for(i.indiv in 1:N){\n      cur.econd=curyear[curhist$emerge[i.indiv],] #grab the envi conditions of the day of emergence of current indiv\n      coef.indiv[index,\"b.day\"]=cur.econd$day*curhist[i.indiv,\"b.day\"]\n      coef.indiv[index,\"b.temp\"]=cur.econd$temp*curhist[i.indiv,\"b.temp\"]\n      coef.indiv[index,\"b.precip\"]=cur.econd$precip*curhist[i.indiv,\"b.precip\"]\n      index=index+1\n    }\n  }\n  return(coef.indiv)\n}\n\nmeanTraitEff<-function(years.index,years.list,pophistory,N){\n  #  Function for calculating the \"mean effect size\" of each coefficient for each indiv\n  #    This is done by multiplying the coefficient of each individual by the mean of the appropriate environmental effect for the appropriate generation\n  #  Inputs:\n  coef.indiv=matrix(data=0,ncol=5,nrow=N*length(years.index),\n                    dimnames = list(NULL,c(\"gen\",\"b.day\",\"b.temp\",\"b.precip\",\"relfit\")))\n  index=1\n  for(i.gen in 1:length(years.index)){\n    curhist=pophistory[[i.gen]]\n    coef.indiv[index:(index+N-1),\"gen\"]=rep(i.gen,N)\n    coef.indiv[index:(index+N-1),\"relfit\"]=curhist$Wi\n    covarmean=c(\"b.const\"=0,\"b.day\"=0,\"b.temp\"=0,\"b.precip\"=0)\n    #This will store the maximum covariable value for this year - max temp, max day, precip, etc.\n    covarmean[\"b.day\"]=mean(years.list[[years.index[i.gen]]]$day)\n    covarmean[\"b.temp\"]=mean(years.list[[years.index[i.gen]]]$temp)\n    covarmean[\"b.precip\"]=mean(years.list[[years.index[i.gen]]]$precip)\n    for(cur.par in c(\"b.day\",\"b.temp\",\"b.precip\")){\n      coef.indiv[index:(index+N-1),cur.par]=abs(curhist[,cur.par])*covarmean[cur.par]\n    }\n    index=index+N\n  }\n  return(coef.indiv)\n}\n\n####################################\n# Year generation functions\n####################################\n\nyeargen.template<-function(){\n  set_wrkdir()\n  fileName=\"fileName.Rdata\"\n  if(file.exists(paste(\"data-years/\",fileName,sep=\"\"))){\n    attach(filename)\n  }else{\n    #THIS IS WHERE WE PULL IN THE IMPUTATION FUNCTION!\n    #years.list=imputation_function()\n    save(list=years.list,file = paste(\"data-years/\",fileName,sep=\"\"))\n  }\n  years.temp=do.call(rbind.data.frame,years.list)\n  daily.fit=dnorm(years.temp$temp,mean=best.temp,sd=sd.temp)*dnorm(years.temp$precip,mean=best.precip,sd=sd.precip)\n}\n\nyeargen.davis<-function(best.precip,sd.precip,best.temp,sd.temp){\n  set_wrkdir()\n  fileName=\"davisDat.Rdata\"\n  if(file.exists(paste(\"data-years/\",fileName,sep=\"\"))){\n    load(paste(\"data-years/\",fileName,sep=\"\"))\n  }else{\n    #THIS IS WHERE WE PULL IN THE IMPUTATION FUNCTION!\n    years.list=yearmk_davis()\n    save(years.list,file = paste(\"data-years/\",fileName,sep=\"\"))\n  }\n  years.temp=do.call(rbind.data.frame,years.list)\n  #add cumulative and squared cues. NOTE THAT SQUARING HAPPENS AFTER CUMSUM!\n  years.temp=cbind(years.temp,\n                   cutemp=cumsum(years.temp$temp),\n                   cuprecip=cumsum(years.temp$precip),\n                   daysq=(years.temp$day)^2,\n                   tempsq=(years.temp$temp)^2,\n                   precipsq=(years.temp$precip)^2,\n                   cutempsq=(cumsum(years.temp$temp))^2,\n                   cuprecipsq=(cumsum(years.temp$precip))^2\n  )\n  fit.daily=dnorm(years.temp$temp,mean=best.temp,sd=sd.temp)*dnorm(years.temp$precip,mean=best.precip,sd=sd.precip)\n  years.temp=cbind(years.temp,fit.daily)\n  years.list=split(years.temp,f=years.temp$year)\n  return(years.list)\n}\n\nyearmk_davis<-function(){\n  #libraries\n  library(timeDate)\n  library(Amelia)\n  library(parallel)\n  #Set appropriate working directory\n  set_wrkdir()\n  #input data\n  davis.daily<-read.csv(\"davis-data/626713.csv\", header=T, na.strings=\"-9999\")\n  davis.daily$YEAR<-as.numeric(substr(davis.daily$DATE,1,4)) #simple field for year\n  davis.daily<-davis.daily[davis.daily$YEAR>1913 & davis.daily$YEAR<2015,] #truncates the data to 101 complete years between 1914 and 2014\n  davis.daily$PRCP<-davis.daily$PRCP/10 #precips are reported in tenths of mm\n  davis.daily$TMAX<-davis.daily$TMAX/10 #temps are reported in tenths of degree C\n  davis.daily$TMIN<-davis.daily$TMIN/10 #temps are reported in tenths of degree C\n  davis.daily$DATE2<-as.Date(as.character(davis.daily$DATE),format=\"%Y %m %d\") #DATE2 is date formatted\n  davis.daily$JULIAN<-julian(davis.daily$DATE2,origin=as.Date(\"1913-12-31\")) #1914-01-01 is day 1\n  davis.daily$MONTH<-as.numeric(substr(davis.daily$DATE,5,6)) #simple field for month\n  davis.daily$DAY<-as.numeric(substr(davis.daily$DATE,7,8)) #simple field for day\n  davis.daily<-davis.daily[,c(\"DATE2\",\"JULIAN\", \"YEAR\",\"MONTH\",\"DAY\",\"PRCP\",\"TMAX\",\"TMIN\")] #simplified dataframe\n  #however, there are 143 missing rows\n  missing.row.count<-max(davis.daily$JULIAN)-length(davis.daily$JULIAN)\n  #this is a list of the missing JULIAN days\n  missing.days<-which((seq(1:max(davis.daily$JULIAN)) %in% davis.daily$JULIAN)==\"FALSE\")\n  #create a empty dataframe with 143 rows\n  missing.days.df <- data.frame(matrix(ncol = 8, nrow = missing.row.count))  #this need to be generalized for any number of missing rows\n  #create matching column names\n  colnames(missing.days.df)<-colnames(davis.daily)\n  #fill in the missing Julian days\n  missing.days.df$JULIAN<-missing.days\n  missing.days.df$DATE2<-as.Date(origin=as.Date(\"1913-12-31\"),missing.days.df$JULIAN)\n  missing.days.df$YEAR<-as.numeric(format(missing.days.df$DATE2, format=\"%Y\"))\n  missing.days.df$MONTH<-as.numeric(format(missing.days.df$DATE2, format=\"%m\"))\n  missing.days.df$DAY<-as.numeric(format(missing.days.df$DATE2, format=\"%d\"))\n  #Combine the two dataframes\n  davis.daily.w.missing.days<-rbind(missing.days.df,davis.daily)\n  #sort by JULIAN\n  davis.daily.w.missing.days<-davis.daily.w.missing.days[order(davis.daily.w.missing.days$JULIAN),]\n  #this is just a shortcut to expedite - should be cleaned up?\n  davis.daily<-davis.daily.w.missing.days\n  davis.yearlist<-split(davis.daily,davis.daily$YEAR) #list of each year separated\n  davis.yearnames<-unique(davis.daily$YEAR) #gives a list of all the years in the data\n  #calculates the \"day of year\", i.e. Jan 1 is 1, and 12/31 is 365\n  #adds a DAY.OF.YEAR column to each dataframe in the year list\n  for (i in 1:length(davis.yearnames)){\n    davis.yearlist[[i]]$DAY.OF.YEAR<-julian(davis.yearlist[[i]]$DATE2, origin=as.Date(paste(davis.yearnames[i],\"01\",\"01\",sep=\"-\")))+1 #add +1 so that the first day of the year is 1, not zero.\n  }\n  davis.daily<-unsplit(davis.yearlist,davis.daily$YEAR)\n  davis.daily.means<-aggregate(cbind(TMAX,TMIN,PRCP)~DAY.OF.YEAR, data=davis.daily, mean)\n  a.out<-amelia(davis.daily,m=1,ts=\"DAY.OF.YEAR\",cs=\"YEAR\",idvars=c(\"DATE2\",\"MONTH\",\"DAY\",\"JULIAN\"),intercs=T,splinetime=6)\n  years.temp=a.out[[1]]$imp1\n  years.temp=years.temp[c(\"DAY.OF.YEAR\",\"TMAX\",\"PRCP\",\"YEAR\")]\n  colnames(years.temp)<-c(\"day\",\"temp\",\"precip\",\"year\")\n  temp=cbind(years.temp$temp,years.temp$temp*0) #for use in following line\n  years.temp$temp=apply(temp,1,max) #ensuring that temperatures are all positive\n  years.list=split(x=years.temp,f=years.temp$year)\n  return(years.list)\n}\n\nyeargen.const<-function(numYears){\n  #generate a sequence of years with identical, gaussian fitness curves, and constant envi conditions.\n  #In this test, fitness is a gauss function centered on day 150\n  modelYear=data.frame(day=1:365,temp=rep(20,365),precip=rep(.5,365),fit.daily=dnorm(1:365,mean=150,sd=30))\n  years.list=list(modelYear)\n  # Each year data frame has $day, $precip, $tmean, $tmax, $tmin\n  # This will be the same list for all configurations of years - this is essentially just our year database\n  years.index=rep(1,numYears) # This is the list of which year.list data to use for each generation of the model\n  return(list(\"years.list\"=years.list,\"years.index\"=years.index))\n}\n\nyeargen.rand<-function(numYears){\n  #generate a sequence of years with identical, gaussian fitness curves, and randomly fluctuating envi conditions.\n  #In this test, fitness is a gauss function centered on day 150\n  modelYear=data.frame(day=1:365,temp=runif(n=365,min=0,max=40),precip=rexp(n=365,rate=10),fit.daily=dnorm(1:365,mean=150,sd=30))\n  years.list=list(modelYear)\n  for(i in 2:max(numYears,100)){\n    years.list[[i]]=data.frame(day=1:365,temp=runif(n=365,min=0,max=40),precip=rexp(n=365,rate=10),fit.daily=dnorm(1:365,mean=150,sd=30))\n  }\n  # Each year data frame has $day, $precip, $tmean, $tmax, $tmin\n  # This will be the same list for all configurations of years - this is essentially just our year database\n  return(list(\"years.list\"=years.list,\"years.index\"=years.index))\n}\n\nyeargen.davistest<-function(numYears,best.temp,sd.temp,best.precip,sd.precip){\n  #Then we use the davis input data, and take some of the \"good years\" - ie no NANs - for our populations\n  #input data\n  davis.daily<-read.csv(\"davis-data/626713.csv\", header=T, na.strings=\"-9999\")\n  davis.daily$PRCP<-davis.daily$PRCP/10 #precips are reported in tenths of mm\n  davis.daily$TMAX<-davis.daily$TMAX/10 #temps are reported in tenths of degree C\n  davis.daily$TMIN<-davis.daily$TMIN/10 #temps are reported in tenths of degree C\n  davis.daily$DATE2<-as.Date(as.character(davis.daily$DATE),format=\"%Y %m %d\") #DATE2 is date formatted\n  davis.daily$JULIAN<-julian(davis.daily$DATE2,origin=as.Date(\"1892-12-31\")) #1893-01-01 is day 1...\n  davis.daily$YEAR<-as.numeric(substr(davis.daily$DATE,1,4)) #simple field for year\n  davis.daily$MONTH<-as.numeric(substr(davis.daily$DATE,5,6)) #simple field for month\n  davis.daily$DAY<-as.numeric(substr(davis.daily$DATE,7,8)) #simple field for day\n  davis.daily<-davis.daily[,c(\"DATE2\",\"JULIAN\", \"YEAR\",\"MONTH\",\"DAY\",\"PRCP\",\"TMAX\",\"TMIN\")] #simplified dataframe\n  davis.yearlist<-split(davis.daily,davis.daily$YEAR) #list of each year separated\n  #calculates the \"day of year\", i.e. Jan 1 is 1, and 12/31 is 365\n  #adds a DAY.OF.YEAR column to each dataframe in the year list\n  davis.yearnames<-unique(davis.daily$YEAR)\n  for (i in 1:length(davis.yearnames)){\n    davis.yearlist[[i]]$DAY.OF.YEAR<-julian(davis.yearlist[[i]]$DATE2, origin=as.Date(paste(davis.yearnames[i],\"01\",\"01\",sep=\"-\")))+1 #add +1 so that the first day of the year is 1, not zero.\n  }\n  yearlist.store=davis.yearlist\n  goodyears=NULL\n  for(iyear in davis.yearnames){\n    nacount=sum(sum(is.na(davis.yearlist[[as.character(iyear)]])))\n    daycount=dim(davis.yearlist[[as.character(iyear)]])[1]\n    if(nacount==0 & daycount>364){goodyears=c(goodyears,iyear)}\n  }\n  davis.yearlist=davis.yearlist[as.character(goodyears)]\n  davis.yearnames<-goodyears #gives a list of all the years in the data\n  davis.daily<-unsplit(yearlist.store,davis.daily$YEAR) #using legacy \"yearlist.store\" to make unsplit happy\n  # DAY.OF.YEAR=rep(0,dim(davis.daily)[1])\n  # for(i in 1:length(DAY.OF.YEAR)){\n  #   DAY.OF.YEAR[i]=sprintf(\"%02d%02d\",davis.daily[i,\"MONTH\"],davis.daily[i,\"DAY\"])\n  #\n  # }\n  # davis.daily=cbind(davis.daily, DAY.OF.YEAR)\n  # davis.daily<-unsplit(davis.daily,davis.daily$YEAR)\n  davis.daily.means<-aggregate(cbind(TMAX,TMIN,PRCP)~DAY.OF.YEAR, data=davis.daily[davis.daily$YEAR %in% goodyears,], mean)\n  davis.yearvar<-data.frame(row.names=davis.yearnames) #dataframe to hold environmental variability\n  for (i in 1:length(davis.yearnames)){\n    #temporary dataframe to compare with mean conditions\n    #this creates a VAR.x for each year and a VAR.y for the daily means\n    comparison<-merge(davis.yearlist[[i]],davis.daily.means,by=\"DAY.OF.YEAR\")\n    #number of complete cases (is.na=F) for each year\n    davis.yearvar[i,\"TMAX.N\"]<-sum(complete.cases(davis.yearlist[[i]]$TMAX))\n    davis.yearvar[i,\"TMIN.N\"]<-sum(complete.cases(davis.yearlist[[i]]$TMIN))\n    davis.yearvar[i,\"PRCP.N\"]<-sum(complete.cases(davis.yearlist[[i]]$PRCP))\n    #sum of squared differences with an average year - how weird is each year?\n    #some years have incomplete data, so this is the mean SS per observed day\n    davis.yearvar[i,\"TMAX.SS\"]<-(sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)^2)/davis.yearvar[i,\"TMAX.N\"]\n    davis.yearvar[i,\"TMIN.SS\"]<-(sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)^2)/davis.yearvar[i,\"TMIN.N\"]\n    davis.yearvar[i,\"PRCP.SS\"]<-(sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)^2)/davis.yearvar[i,\"PRCP.N\"]\n    #CV within years - how variable is each year?\n    davis.yearvar[i,\"TMAX.CV\"]<-sd(comparison$TMAX.x,na.rm=T)/mean(comparison$TMAX.x,na.rm=T)\n    davis.yearvar[i,\"TMIN.CV\"]<-sd(comparison$TMIN.x,na.rm=T)/mean(comparison$TMIN.x,na.rm=T)\n    davis.yearvar[i,\"PRCP.CV\"]<-sd(comparison$PRCP.x,na.rm=T)/mean(comparison$PRCP.x,na.rm=T)\n    #sum of differences (not squared) with an average year - how hot/wet is each year?\n    #some years have incomplete data, so this is the mean difference per observed day\n    davis.yearvar[i,\"TMAX.DEL\"]<-sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)/davis.yearvar[i,\"TMAX.N\"]\n    davis.yearvar[i,\"TMIN.DEL\"]<-sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)/davis.yearvar[i,\"TMIN.N\"]\n    davis.yearvar[i,\"PRCP.DEL\"]<-sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)/davis.yearvar[i,\"PRCP.N\"]\n    ######################\n    # Fitness generation #\n    ######################\n    #For now, daily incremental fitness will be found by multiplying two gaussian functions together:\n    #  one for temp, that's maximized at best.temp with sd tempsd\n    #  the other for precip that's maximized at best.precip with sd precipsd\n    # We will then normalize the results to vary from 0 to 1\n    years.list=davis.yearlist\n    for(i.year in 1:length(years.list)){\n      newyear=years.list[[i.year]]\n      newyear=newyear[,c(\"DAY.OF.YEAR\",\"TMAX\",\"PRCP\")]\n      colnames(newyear)<-c(\"day\",\"tmax\",\"precip\")\n      daily.fit=dnorm(newyear$tmax,mean=best.temp,sd=sd.temp)*dnorm(newyear$precip,mean=best.precip,sd=sd.precip)\n      daily.fit=(daily.fit-min(daily.fit))/(max(daily.fit)-min(daily.fit))\n      years.list[[i.year]]=cbind(newyear, fit.daily=daily.fit)\n    }\n    # Each year data frame has $day, $precip, $tmean, $tmax, $tmin\n    # This will be the same list for all configurations of years - this is essentially just our year database\n  }\n  years.index=rep(c(1,2,3,4,5,6,7,8,9,10),length.out=numYears) # This is the list of which year.list data to use for each generation of the model\n  years.list=davis.yearlist #Replace this with code to grab a list of data frames. Each data frame is a year.\n  return(list(\"years.index\"=years.index,\"years.list\"=years.list))\n}\n######################\n# Plotting Functions #\n######################\n\nemergePlot<-function(indivs,traitName){\n  #Function for plotting trait values through time\n  #Inputs:\n  #  generations: vector of the generation of each individual to be plotted\n  #  traivals: vector of the trait value of interest of each individ to be plotted\n  #  mainlabel: label for the main graph\n  #  ylabel: label for Y axis\n  maxCount=100 #maximum number of years to count\n  generations=indivs[,\"gen\"]\n  if(length(unique(generations))>maxCount){\n    viewGens=floor(seq(min(generations),max(generations),length.out=maxCount))\n    goodInd=generations %in% viewGens\n    generations=generations[goodInd]\n    indivs=indivs[goodInd,]\n  }\n  plot(jitter(generations),indivs[,traitName],type='n',\n       main=paste(\"Actual effect size of\",traitName),\n       xlab=\"Generation\",\n       ylab=paste(traitName,\"effect size\"),\n       cex.lab=1.4,cex.main=1.4)\n  #Plot the \"emerge before last day\" indivs\n  points(jitter(generations[indivs[,\"emerge\"]>364]),indivs[indivs[,\"emerge\"]>364,traitName],pch=3,col='blue')\n  points(jitter(generations[indivs[,\"emerge\"]<365]),indivs[indivs[,\"emerge\"]<365,traitName],pch=1)\n}\ntraiteffplot<-function(indivs,traitName){\n  #Function for plotting trait values through time\n  #Inputs:\n  #  generations: vector of the generation of each individual to be plotted\n  #  traivals: vector of the trait value of interest of each individ to be plotted\n  #  mainlabel: label for the main graph\n  maxCount=100 #maximum number of years to count\n  generations=indivs[,\"gen\"]\n  if(length(unique(generations))>maxCount){\n    viewGens=floor(seq(min(generations),max(generations),length.out=maxCount))\n    goodInd=generations %in% viewGens\n    generations=generations[goodInd]\n    indivs=indivs[goodInd,]\n  } #  ylabel: label for Y axis\n  plot(jitter(indivs[,\"gen\"]),indivs[,traitName],pch=1,\n       main=paste(\"Expected effect size of\",traitName),\n       xlab=\"Generation\",\n       ylab=paste(traitName,\"effect size\"),\n       cex.lab=1.4,cex.main=1.4)\n}\ntraitplot<-function(indivs,traitName){\n  #Function for plotting trait values through time\n  #Inputs:\n  #  generations: vector of the generation of each individual to be plotted\n  #  traivals: vector of the trait value of interest of each individ to be plotted\n  #  mainlabel: label for the main graph\n  #  ylabel: label for Y axis\n  maxCount=100 #maximum number of years to count\n  generations=indivs[,\"gen\"]\n  if(length(unique(generations))>maxCount){\n    viewGens=floor(seq(min(generations),max(generations),length.out=maxCount))\n    goodInd=generations %in% viewGens\n    generations=generations[goodInd]\n    indivs=indivs[goodInd,]\n  }\n  plot(jitter(generations),indivs[,traitName],type='n',\n       main=paste(\"Coefficient values of\",traitName),\n       xlab=\"Generation\",\n       ylab=paste(traitName,\"values\"),\n       cex.lab=1.4,cex.main=1.4)\n  #Plot the \"emerge before last day\" indivs\n  points(jitter(generations[indivs[,\"emerge\"]>364]),indivs[indivs[,\"emerge\"]>364,traitName],pch=3,col='blue')\n  points(jitter(generations[indivs[,\"emerge\"]<365]),indivs[indivs[,\"emerge\"]<365,traitName],pch=1)\n}\n",
    "created" : 1461270318960.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3158665275",
    "id" : "D2EFAF09",
    "lastKnownWriteTime" : 1461269296,
    "last_content_update" : 1461269296,
    "path" : "~/GitHub/phenology-cues/scripts/windows_subs.R",
    "project_path" : "scripts/windows_subs.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}