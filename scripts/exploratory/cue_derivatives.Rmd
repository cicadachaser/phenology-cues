---
title: "Comparing smoothing approaches"
author: "Collin Edwards"
date: "January 3, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#getting the the right working directory, etc
set_wrkdir<-function(){
  #function for setting working directory to the right place given the current computer/user
  if(Sys.getenv("USERNAME")=="Collin" || Sys.getenv("USERNAME")=="collin" || Sys.getenv("USERNAME")=="Collin.work"){ #If it's collin
    if(Sys.info()["nodename"]=="DESKTOP-D6QSU8F"){
      setwd("G:\\Repos\\phenology-cues") #desktop
    }else{
      setwd("C:\\Repos\\phenology-cues") #desktop
    }
  }else{
    if(Sys.getenv("COMPUTERNAME")=="ENT-YANG01"){
      setwd("C:\\Users\\louie\\Documents\\GitHub\\phenology-cues")#desktop
    }else{
      setwd("C:\\Users\\louie\\Documents\\GitHub\\phenology-cues")} #laptop
  }
}
```

## Objective
We want to give organisms a cue that allows them to respond to seasonality. We feel that derivative of temperature should do this. However, temperature is noisy. We find that if we just use derivative of temperature, it's non-informative.


```{r,message=FALSE}
set_wrkdir()
source("scripts/exploratory/explore_funs.R")
exp_covars(dat.file="davisDat.Rdata",fit.file = "standgauss.R",decay=.1,interests=c("temp","dtemp","fit.tot"))
```

Look at the centeral column of plots: we would like something that looks largely like a smooth line trending from top left to bottom right. Instead, we get something very wiggly. Wiggly suggests we need to smooth something. My thought is to smooth the original temperature, and then calculate the derivative from that. This has some biological realism - organisms can likely judge trends of recent weather. 

##Complication: no psychics
Smoothers take information both from the left and the right of a focal point to make predictions. We don't want organisms to be able to use the future to estimate trends. So we'll need apply the smoother to the "experienced" temperatures, for every set of experienced temperatures. That is, we'll apply the smoother on days 1:10 before determining the smoothed derivative of temperature on day 10, then we'll apply the smoother on days 1:11 before determining the smoothed derivative of temperature on day 11, etc. For day 1, we have no estimate of derivatve so we'll assume it's 0. For day 2, we will just assume the difference between day 1 and day 2 (?? or should we set it to zero as well?).

##Choosing Smoother

We need to think about which smoother to use. Two come to mind: loess and smoothing splines. Let's compare them. Note that because they use different smoothing techniques, comparing the smoothing parameters between spline and loess fits isn't meaningful. Instead, we should compare their approximate degrees of freedom ($df for spline fitting, and the trace of the hat matrix, $trace.hatmatrix, for loess fitting).

```{r}
#Reading in parameters, setting things up
i.year=5 #year to check
day=80 #"current" day
smooth.default=.5

#Load in year
years.list=yeargen("davisDat.Rdata",fit.parms=fit.parms)[[1]] #this uses the fitness parameters and fitness function listed above
year.cur=years.list[[i.year]]
require(stats)
```

Let's do a spline fit and plot the temperature the organism experienced in black, the trendline in blue, and the actual next 10 days of temperature in red
```{r}
##Quick test of smooth.spline
# dat=sin((1:day)/pi)*5+runif(day)*3
# temp.spl=smooth.spline(x=dat,spar=smooth.parm,all.knots=TRUE)
# temp.pred=predict(temp.spl,x=(1:day))
# plot(dat)
# points(temp.pred,type='l',col='blue')
smooth.parm=.57
temp.spl=smooth.spline(x=year.cur[1:day,"temp"],spar=smooth.parm,all.knots=TRUE)
temp.pred=predict(temp.spl,x=1:day, deriv=0)
pred.y=temp.pred$y
plot(year.cur$temp[1:(day+10)],type="n",
     xlab="Day",
     ylab="Temperature",
     main=paste("Spline fit, smoothing parm of",smooth.parm))
points(1:day,year.cur$temp[1:(day)],pch=19)
points((day+1):(day+10),year.cur$temp[(day+1):(day+10)],col='red',pch=19)
points(1:day, pred.y,col='blue',type="l")
text(labels=paste("~df = ",temp.spl$df),x=1,y=25,cex=1,pos=4)

```

Now let's do this with LOESS
```{r}
smooth.parm=.2 #smoothing parameter
temp.ls=loess(temp~day,span=smooth.parm,data=year.cur[1:day,])
temp.pred=predict(temp.ls,x=year.cur[1:day,"temp"])
pred.y=temp.pred
plot(year.cur$temp[1:(day+10)],type="n",
     xlab="Day",
     ylab="Temperature",
     main=paste("LOESS fit, smoothing parm of",smooth.parm))
points(1:day,year.cur$temp[1:(day)],pch=19)
points((day+1):(day+10),year.cur$temp[(day+1):(day+10)],col='red',pch=19)
points(1:day, pred.y,col='blue',type="l")
text(labels=paste("~df = ",temp.ls$trace.hat),x=1,y=25,cex=1,pos=4)
```

Both of these look like they work. The smooth.spline has the advantage that it is actively smoothing the derivative, so we would expect the derivative to be smooth, plus it's incredibly easy to estimate the derivative at a point. So let's go with that.

##Smoothing parameter

Now the tricky part is to figure out what smoothing parameter to use. In general, there will be a tradeoff between predicting the near feature by catching local trends vs being resilient to variance. And remember, we're trying to reduce variance sufficiently that our smoothing produces derivatives that are actually useful. Above, we used smooth.parm=.57. This seemed to do a good job of catching the local trends, but our estimated dtemps will still fluctuate a lot. If we use the same smooth.parm=.57, what does our estimated derivative plot look like for that year?
We'll plot the temperature, the smoothed temperature when smoothing across the whole year, and then the estimated derivative of the temperature.
```{r,echo=TRUE}
smooth.parm=.57
deriv.store=rep(0,365)
for(day in 4:365){
  temp.spl=smooth.spline(x=year.cur[1:day,"temp"],spar=smooth.parm,all.knots=TRUE)
  deriv.store[day]=predict(temp.spl,day,deriv=1)$y
}
plot(year.cur$temp, main="temperature")
temp.spl=smooth.spline(x=year.cur[1:365,"temp"],spar=smooth.parm,all.knots=TRUE)
points(predict(temp.spl,x=1:365),type='l',col='blue',lwd=2)
plot(deriv.store,type='l',main="estimated dtemp")
```

So. That doesn't look to good. Perhaps we need a stronger smoothing? Let's try smooth.parm=.1.2

```{r,echo=FALSE}
smooth.parm=1.3
deriv.store=rep(0,365)
for(day in 4:365){
  temp.spl=smooth.spline(x=year.cur[1:day,"temp"],spar=smooth.parm,all.knots=TRUE)
  deriv.store[day]=predict(temp.spl,day,deriv=1)$y
}
plot(year.cur$temp, main="temperature")
temp.spl=smooth.spline(x=year.cur[1:365,"temp"],spar=smooth.parm,all.knots=TRUE)
points(predict(temp.spl,x=1:365),type='l',col='blue',lwd=2)
plot(deriv.store,type='l',main="estimated dtemp")
```

That's starting to look a bit better, aside from the bit at the beginning. That said, the weirdness at the beginning AND a lot of the noisiness is due to the fact that we are refitting with a new day for every day. This makes the fit biologically realistic (they can't see the future in order to find the trend), but much messier. And the uglyness at the beginning is because there's a very high variance when fitting so few data points. This becomes apparent when we estimate the derivatives for all points using a smooth of ALL the data:

```{r}
plot(predict(temp.spl,x=1:365,deriv=1),type='l',col='blue',lwd=2,
     main="Derivative predicted by smoothing of all the data")
```

###Getting somewhere!
If we examine our estimated dtemp after the first 50 days (ie once there's enough data for smooth.spline to be decent), we get something that looks fairly promising!

```{r}

plot(50:365,deriv.store[50:365],type='l',main="estimated dtemp")
```

That's the kind of shape we were looking for, although perhaps we hadn't inteded there to be quite as much noise. But that's looking promising. However, I'm not sure how to handle the initial 50 days. Perhaps there is some kind of bayesian approach that would allow us to use multiple years to create a prior for the derivative of temperature on the early days, but I'm not familiar with bayesian approaches and I'm hesitant to add that level of complication.

#Sort of Appendix-y Stuff

##Equivalent methods
Just to be safe for later comparisons, let's see what happens if we use smooth.spline to predict the temperature of day and day-1, and use the difference of those two as the derivative. We'll have to use that in our loess test.

```{r,echo=FALSE}
smooth.parm=1.2
deriv.store=rep(0,365)
for(day in 4:365){
  temp.spl=smooth.spline(x=year.cur[1:day,"temp"],spar=smooth.parm,all.knots=TRUE)
  days=predict(temp.spl,c(day-1,day),deriv=0)$y
  deriv.store[day]=diff(days)
}
plot(year.cur$temp, main="temperature")
temp.spl=smooth.spline(x=year.cur[1:365,"temp"],spar=smooth.parm,all.knots=TRUE)
points(predict(temp.spl,x=1:365),type='l',col='blue',lwd=2)
plot(deriv.store,type='l',main="estimated dtemp")
```

Yup! Same general trend. We can compare this with LOESS

##Checking out LOESS version
Let's just see if LOESS produces a more consistent pattern using the same "fit every day and predict" approach. Because predict.loess can't predict derivatives, we instead use the same difference method we tested above.

```{r,echo=TRUE}
#First, let's check the degrees of freedom for reference:
temp.spl$df
smooth.parm=.6
deriv.store=rep(0,365)
for(day in 10:365){
  temp.ls=loess(temp~day, span=smooth.parm, data=year.cur[1:day,])
  days=predict(temp.ls,newdata=c(day-1,day))
  deriv.store[day]=diff(days)
}
plot(year.cur$temp, main="temperature")
temp.ls=loess(temp~day, span=smooth.parm, data=year.cur)
temp.ls$trace.hat
points(predict(temp.ls,newdata=1:365),type='l',col='blue',lwd=2)
plot(deriv.store,type='l',main="estimated dtemp")
```

This has the same issues - loess doesn't solve the problem. Plus the initial weirdness lasts much longer - the spline fit does a better job with smaller data sets. So smooth.spline is the way to go.

