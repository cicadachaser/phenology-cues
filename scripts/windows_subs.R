#Updated through "fitness" function

emerge_sub<-function(x){min(c(which(x),366))} #function for use in "apply" within emergence()

emergence<-function(year,newpop){
  #Function for calculating the emergence day of the given individual in the given year.
  #  Calculates emergence value as E= b.day*day+b.temp*temp+b.precip*precip
  # Then finds the first day when the calculated E is greater than 100 (100 chosen for arbitrary convenience)
  # Inputs:
  #  Indiv: (individual) has three important attributes: $b.day, $b.temp, $b.precip
  #  year: current year data. Includes columns $day, $tmax, $precip
  # Output:
  #  day (Julian) of emergence
  E=newpop$b.day %*% t(year$day) + newpop$b.temp %*% t(year$temp) + newpop$b.precip %*% t(year$precip) +
    newpop$b.cutemp %*% t(year$cutemp) + newpop$b.cuprecip %*% t(year$cuprecip) +
    newpop$b.daysq %*% t(year$daysq) + newpop$b.tempsq %*% t(year$tempsq) + newpop$b.precipsq %*% t(year$precipsq) +
    newpop$b.cutempsq %*% (t(year$cutempsq)^2) + newpop$b.cuprecipsq %*% t(year$cuprecipsq)
  emerge=apply(E>100,1,emerge_sub)
  return(emerge) #find the first day where emergence value is greater than 100 (or the last day of the year)
}
fitness<-function(year,newpop,duration){
  #Function for giving fitness of individuals based on their start time, duration, and the W.
  # fitness is the sum of W over the lifespan
  #FOR SIMPLICITY, ASSUMING END OF YEAR MEANS DEATH. CHANGE IF APPROPRIATE.
  #Inputs:
  #  year: data frame of climate and fitness information for current year. Includes $fit.daily column
  #  newpop: matrix of individuals, with each row corresponding to an individual, rows $b.const, $b.day, $b.temp, $b.precip
  #  duration: number of days organism is emerged
  #Returns:
  #  fit: vector of the fitnesses of each individual
  #
  evect=emergence(year=year,newpop=newpop)
  #Create a vector with the "total fitness you experience if you emerge on this day" values.
  # (using rollapply function from "zoo" library to make this fast)
  # Adding a 0 at the end of the vector: if you didn't emerge in the normal year, you "emerge" on day 366 which has zero fitness. ie if you don't emerge you die.
  fitVals=c(rollapply(c(year$fit.daily,rep(0,duration-1)),duration,by=1,sum),0)
  fit=fitVals[evect]
  return(data.frame(fit=fit,emerge=evect))
}

selection<-function(newpop,duration,year,N){
  #Function for carrying out `soft selection' - all individuals reproduce, with variable fitness.
  #Inputs:
  #  newpop: data frame with the current population trait values; each row is an individual
  #  year: data on the year, including a column for daily fitness
  #  duration: lifespan of organisms
  #  N: number of individuals in the population
  #Returns:
  #  newpop: a matrix with the current population traits, plus raw fitness (Wi),
  #     rescaled fitness(Ws), proportional fitness after mortality(Wp), and number of offspring (Wnum)
  #
  out=fitness(year=year,newpop=newpop,duration=duration)
  newWi=out$fit
  newWnum=(rmultinom(1,size=N,prob=newWi)) #To avoid potential rounding weirdness, had individuals assigned via the multinomial distribution
  init.colnames=colnames(newpop)
  newpop<-cbind(newpop,out$emerge,newWi,newWnum)
  colnames(newpop)<-c(init.colnames,"emerge","Wi","Wnum")
  return(newpop)
}

mutation<-function(poptraits,sds,mutrate,N){
  #Function that creates random offspring with variable t.start and t.duration values
  #Inputs:
  #  poptraits: a matrix of just the traits for the current population
  #  sds: 1-d data frame of standard deviations for mutations of the various traits. Has values $const, $day, $temp, $precip
  #  mutrate: 1-d data frame for PROBABILITY of mutation for each of the traits. Has values $const, $day, $temp, $precip
  #Returns
  #  2-dimensional matrix of the new (post-mutation) traits of the population
  #
  mat.runif=matrix(runif(length(sds)*N),nrow=N, ncol=length(sds)) #generate matrix of random uniform numbers for testing
  #make a data frame with N rows, each row being a duplicate of the mutrate list
  mutframe=data.frame(t(unlist(mutrate))) #one row
  test.mutate=mutframe[rep(1,N),] #sneaky way to make N rows
  mat.mutate=mat.runif<test.mutate # which traits of which individuals mutated?
  #This is a little dicey, but when executed correctly (like here), allows me to make our entire rnorm matrix in one shot.
  #It relies on the INCREDIBLY STUPID FACT that R recycles vectors when needed. I don't like it, but the code works and is quick.
  vals.mutate=matrix(rnorm(n=N*length(sds),mean=0,sd=unlist(sds)),N,length(sds),byrow=TRUE)
  colnames(vals.mutate)<-sprintf("b.%s",names(sds))
  poptraits=poptraits+mat.mutate*vals.mutate #Take current population, add mutations only for individuals and traits that mutated.
  return(poptraits)
}

reproduction<-function(pop){
  #THIS FUNCTION CAN PROBABLY BE MADE MUCH FASTER
  #Function for handling reproduction
  #Inputs:
  #  pop: population data frame generated by selection() function. Includes Wnum
  #Returns:
  #  Next generation as a data frame.
  repop<-pop[pop$Wnum>0,]
  nameslist=sprintf("b.%s",names(sds))
  expandpop<-data.frame(t(rep(0,length(sds))))[rep(1,N),]
  colnames(expandpop)<-nameslist
  ind=1
  for(i in 1:nrow(repop)){
    for (j in 1:repop$Wnum[i]) {
      expandpop[ind,]<-repop[i,!names(repop) %in% c("emerge","Wi","Wnum")]
      ind=ind+1
    }
  }
  return(expandpop)
}
runSim<-function(startpop,years.list,years.ind,N,duration,sds,mutrate,generations,graphics=FALSE){
  #Function that actually runs the simulation (calling the other functions above)
  #Inputs:
  #  startpop: initial population
  #  years.list: List of dataframes for daily information on each year (MUST INCLUDE DAILY FITNESS)
  #  years.ind: vector of indices for the year to use for each generation.
  #  N: number of individuals in the population
  #  duration: number of days all individuals is in an emerged state
  #  sds: standard deviation for the distribution of mutation sizes for each trait
  #  mutrate: probability of mutation for each trait (per individual).
  #  generations: number of generations to simulate.
  #  graphics: boolean, defaults to false. If true, carry out some plotting operations
  #Returns
  #  pophistory: list where each element represents the full population data frame for each generation
  #
  pop=startpop
  pophistory<-list(cbind(startpop, gen=rep(1,N))) #initialize the population history
  for(g in 2:generations){
    #reproduction
    cur.year=years.list[[years.ind[g]]]
    newpop<-reproduction(pop=pop)
    newpop<-mutation(poptraits=newpop,sds=sds,mutrate=mutrate,N=N)
    newpop<-selection(newpop=newpop,duration=duration,year=cur.year,N=N)
    pophistory[[g]]<-cbind(newpop, gen=rep(g,N))
    pop<-newpop
  }
  return(pophistory)
}

######################
# Analysis Functions #
######################

#####
actTraitVals<-function(pophistory,numYears,N){
  traitslist=sprintf("b.%s",traits)
  coef.indiv=matrix(data=0,ncol=(3+length(traitslist)),nrow=N*numYears,
                    dimnames = list(NULL,c("gen",traitslist,"relfit","emerge")))
  ind=1
  for(i.gen in 1:numYears){
    curhist=pophistory[[i.gen]]
    coef.indiv[ind:(ind+N-1),"gen"]=rep(i.gen,N)
    coef.indiv[ind:(ind+N-1),"relfit"]=curhist$Wi
    coef.indiv[ind:(ind+N-1),"emerge"]=curhist$emerge
    coef.indiv[ind:(ind+N-1),traitslist]=as.matrix(curhist[,traitslist])
    ind=ind+N
  }
  return(coef.indiv)
}

##NEXT DO THIS ONE!
# actTraitEff<-function(years.ind,years.list,pophistory,N){
#   #  Function for calculating the actual effect size of each coefficient for each indiv
#   #    This is done by finding the conditions when each individual emerged, and calculating the effect of each coefficient on that day.
#   #  Inputs:
#   traitslist=sprintf("b.%s",traits)
#   coef.indiv=matrix(data=0,ncol=(3+length(traitslist)),nrow=N*numYears,
#                     dimnames = list(NULL,c("gen",traitslist,"relfit","emerge")))
#   ind=1
#   for(i.gen in 1:length(years.ind)){
#     curhist=pophistory[[i.gen]] #store the current year of population date
#     curyear=years.list[[years.ind[[i.gen]]]] #store the current year of envi conditions
#     coef.indiv[ind:(ind+N-1),"gen"]=rep(i.gen,N)
#     coef.indiv[ind:(ind+N-1),"relfit"]=curhist$Wi
#     coef.indiv[ind:(ind+N-1),"emerge"]=curhist$emerge
#     for(i.indiv in 1:N){
#       cur.econd=curyear[curhist$emerge[i.indiv],] #grab the envi conditions of the day of emergence of current indiv
#       coef.indiv[ind,"b.day"]=cur.econd$day*curhist[i.indiv,"b.day"]
#       coef.indiv[ind,"b.temp"]=cur.econd$temp*curhist[i.indiv,"b.temp"]
#       coef.indiv[ind,"b.precip"]=cur.econd$precip*curhist[i.indiv,"b.precip"]
#       ind=ind+1
#     }
#   }
#   return(coef.indiv)
# }

actTraitEff<-function(years.ind,years.list,pophistory,N){
  #  Function for calculating the actual effect size of each coefficient for each indiv
  #    This is done by finding the conditions when each individual emerged, and calculating the effect of each coefficient on that day.
  #  Inputs:
  traitslist=sprintf("b.%s",traits)
  coef.indiv=matrix(data=0,ncol=(3+length(traitslist)),nrow=N*numYears,
                    dimnames = list(NULL,c("gen",traitslist,"relfit","emerge")))
  ind=1
  for(i.gen in 1:length(years.ind)){
    curhist=pophistory[[i.gen]] #store the current year of population date
    curyear=years.list[[years.ind[[i.gen]]]] #store the current year of envi conditions
    coef.indiv[ind:(ind+N-1),"gen"]=rep(i.gen,N)
    coef.indiv[ind:(ind+N-1),"relfit"]=curhist$Wi
    coef.indiv[ind:(ind+N-1),"emerge"]=curhist$emerge
    for(i.indiv in 1:N){
      cur.econd=curyear[curhist$emerge[i.indiv],] #grab the envi conditions of the day of emergence of current indiv
      coef.indiv[ind,traitslist]=as.matrix(cur.econd[,unlist(traits)]*curhist[i.indiv,traitslist])
      ind=ind+1
    }
  }
  return(coef.indiv)
}

####################################
# Year generation functions
####################################

yeargen.template<-function(){
  set_wrkdir()
  fileName="fileName.Rdata"
  if(file.exists(paste("data-years/",fileName,sep=""))){
    attach(filename)
  }else{
    #THIS IS WHERE WE PULL IN THE IMPUTATION FUNCTION!
    #years.list=imputation_function()
    save(list=years.list,file = paste("data-years/",fileName,sep=""))
  }
  years.temp=do.call(rbind.data.frame,years.list)
  daily.fit=dnorm(years.temp$temp,mean=best.temp,sd=sd.temp)*dnorm(years.temp$precip,mean=best.precip,sd=sd.precip)
}

yeargen.davis<-function(best.precip,sd.precip,best.temp,sd.temp){
  set_wrkdir()
  fileName="davisDat.Rdata"
  if(file.exists(paste("data-years/",fileName,sep=""))){
    load(paste("data-years/",fileName,sep=""))
  }else{
    #THIS IS WHERE WE PULL IN THE IMPUTATION FUNCTION!
    years.list=yearmk_davis()
    save(years.list,file = paste("data-years/",fileName,sep=""))
  }
  years.temp=do.call(rbind.data.frame,years.list)
  #add cumulative and squared cues. NOTE THAT SQUARING HAPPENS AFTER CUMSUM!
  years.temp=cbind(years.temp,
                   cutemp=0*years.temp$temp,
                   cuprecip=0*(years.temp$precip),
                   daysq=0*(years.temp$day),
                   tempsq=0*(years.temp$temp),
                   precipsq=0*(years.temp$precip),
                   cutempsq=0*(cumsum(years.temp$temp)),
                   cuprecipsq=0*(cumsum(years.temp$precip))
  )
   fit.daily=dnorm(years.temp$temp,mean=best.temp,sd=sd.temp)*dnorm(years.temp$precip,mean=best.precip,sd=sd.precip)
  years.temp=cbind(years.temp,fit.daily)
  years.list=split(years.temp,f=years.temp$year)
  for(i.year in 1:length(years.list)){
    years.list[[i.year]]$cutemp=cumsum(years.list[[i.year]]$temp);
    years.list[[i.year]]$cuprecip=cumsum(years.list[[i.year]]$precip);
    years.list[[i.year]]$daysq=(years.list[[i.year]]$day)^2;
    years.list[[i.year]]$tempsq=(years.list[[i.year]]$temp)^2;
    years.list[[i.year]]$precipsq=(years.list[[i.year]]$precip)^2;
    years.list[[i.year]]$cutempsq=cumsum((years.list[[i.year]]$temp)^2);
    years.list[[i.year]]$cuprecipsq=cumsum((years.list[[i.year]]$precip)^2);
    }
  return(years.list)
}

yearmk_davis<-function(){
  #libraries
  library(timeDate)
  library(Amelia)
  library(parallel)
  #Set appropriate working directory
  set_wrkdir()
  #input data
  davis.daily<-read.csv("davis-data/626713.csv", header=T, na.strings="-9999")
  davis.daily$YEAR<-as.numeric(substr(davis.daily$DATE,1,4)) #simple field for year
  davis.daily<-davis.daily[davis.daily$YEAR>1913 & davis.daily$YEAR<2015,] #truncates the data to 101 complete years between 1914 and 2014
  davis.daily$PRCP<-davis.daily$PRCP/10 #precips are reported in tenths of mm
  davis.daily$TMAX<-davis.daily$TMAX/10 #temps are reported in tenths of degree C
  davis.daily$TMIN<-davis.daily$TMIN/10 #temps are reported in tenths of degree C
  davis.daily$DATE2<-as.Date(as.character(davis.daily$DATE),format="%Y %m %d") #DATE2 is date formatted
  davis.daily$JULIAN<-julian(davis.daily$DATE2,origin=as.Date("1913-12-31")) #1914-01-01 is day 1
  davis.daily$MONTH<-as.numeric(substr(davis.daily$DATE,5,6)) #simple field for month
  davis.daily$DAY<-as.numeric(substr(davis.daily$DATE,7,8)) #simple field for day
  davis.daily<-davis.daily[,c("DATE2","JULIAN", "YEAR","MONTH","DAY","PRCP","TMAX","TMIN")] #simplified dataframe
  #however, there are 143 missing rows
  missing.row.count<-max(davis.daily$JULIAN)-length(davis.daily$JULIAN)
  #this is a list of the missing JULIAN days
  missing.days<-which((seq(1:max(davis.daily$JULIAN)) %in% davis.daily$JULIAN)=="FALSE")
  #create a empty dataframe with 143 rows
  missing.days.df <- data.frame(matrix(ncol = 8, nrow = missing.row.count))  #this need to be generalized for any number of missing rows
  #create matching column names
  colnames(missing.days.df)<-colnames(davis.daily)
  #fill in the missing Julian days
  missing.days.df$JULIAN<-missing.days
  missing.days.df$DATE2<-as.Date(origin=as.Date("1913-12-31"),missing.days.df$JULIAN)
  missing.days.df$YEAR<-as.numeric(format(missing.days.df$DATE2, format="%Y"))
  missing.days.df$MONTH<-as.numeric(format(missing.days.df$DATE2, format="%m"))
  missing.days.df$DAY<-as.numeric(format(missing.days.df$DATE2, format="%d"))
  #Combine the two dataframes
  davis.daily.w.missing.days<-rbind(missing.days.df,davis.daily)
  #sort by JULIAN
  davis.daily.w.missing.days<-davis.daily.w.missing.days[order(davis.daily.w.missing.days$JULIAN),]
  #this is just a shortcut to expedite - should be cleaned up?
  davis.daily<-davis.daily.w.missing.days
  davis.yearlist<-split(davis.daily,davis.daily$YEAR) #list of each year separated
  davis.yearnames<-unique(davis.daily$YEAR) #gives a list of all the years in the data
  #calculates the "day of year", i.e. Jan 1 is 1, and 12/31 is 365
  #adds a DAY.OF.YEAR column to each dataframe in the year list
  for (i in 1:length(davis.yearnames)){
    davis.yearlist[[i]]$DAY.OF.YEAR<-julian(davis.yearlist[[i]]$DATE2, origin=as.Date(paste(davis.yearnames[i],"01","01",sep="-")))+1 #add +1 so that the first day of the year is 1, not zero.
  }
  davis.daily<-unsplit(davis.yearlist,davis.daily$YEAR)
  davis.daily.means<-aggregate(cbind(TMAX,TMIN,PRCP)~DAY.OF.YEAR, data=davis.daily, mean)
  a.out<-amelia(davis.daily,m=1,ts="DAY.OF.YEAR",cs="YEAR",idvars=c("DATE2","MONTH","DAY","JULIAN"),intercs=T,splinetime=6)
  years.temp=a.out[[1]]$imp1
  years.temp=years.temp[c("DAY.OF.YEAR","TMAX","PRCP","YEAR")]
  colnames(years.temp)<-c("day","temp","precip","year")
  temp=cbind(years.temp$temp,years.temp$temp*0) #for use in following line
  years.temp$temp=apply(temp,1,max) #ensuring that temperatures are all positive
  years.list=split(x=years.temp,f=years.temp$year)
  return(years.list)
}

yeargen.const<-function(numYears){
  #generate a sequence of years with identical, gaussian fitness curves, and constant envi conditions.
  #In this test, fitness is a gauss function centered on day 150
  modelYear=data.frame(day=1:365,temp=rep(20,365),precip=rep(.5,365),fit.daily=dnorm(1:365,mean=150,sd=30))
  years.list=list(modelYear)
  # Each year data frame has $day, $precip, $tmean, $tmax, $tmin
  # This will be the same list for all configurations of years - this is essentially just our year database
  years.index=rep(1,numYears) # This is the list of which year.list data to use for each generation of the model
  return(list("years.list"=years.list,"years.index"=years.index))
}

yeargen.rand<-function(numYears){
  #generate a sequence of years with identical, gaussian fitness curves, and randomly fluctuating envi conditions.
  #In this test, fitness is a gauss function centered on day 150
  modelYear=data.frame(day=1:365,temp=runif(n=365,min=0,max=40),precip=rexp(n=365,rate=10),fit.daily=dnorm(1:365,mean=150,sd=30))
  years.list=list(modelYear)
  for(i in 2:max(numYears,100)){
    years.list[[i]]=data.frame(day=1:365,temp=runif(n=365,min=0,max=40),precip=rexp(n=365,rate=10),fit.daily=dnorm(1:365,mean=150,sd=30))
  }
  # Each year data frame has $day, $precip, $tmean, $tmax, $tmin
  # This will be the same list for all configurations of years - this is essentially just our year database
  return(list("years.list"=years.list,"years.index"=years.index))
}

yeargen.davistest<-function(numYears,best.temp,sd.temp,best.precip,sd.precip){
  #Then we use the davis input data, and take some of the "good years" - ie no NANs - for our populations
  #input data
  davis.daily<-read.csv("davis-data/626713.csv", header=T, na.strings="-9999")
  davis.daily$PRCP<-davis.daily$PRCP/10 #precips are reported in tenths of mm
  davis.daily$TMAX<-davis.daily$TMAX/10 #temps are reported in tenths of degree C
  davis.daily$TMIN<-davis.daily$TMIN/10 #temps are reported in tenths of degree C
  davis.daily$DATE2<-as.Date(as.character(davis.daily$DATE),format="%Y %m %d") #DATE2 is date formatted
  davis.daily$JULIAN<-julian(davis.daily$DATE2,origin=as.Date("1892-12-31")) #1893-01-01 is day 1...
  davis.daily$YEAR<-as.numeric(substr(davis.daily$DATE,1,4)) #simple field for year
  davis.daily$MONTH<-as.numeric(substr(davis.daily$DATE,5,6)) #simple field for month
  davis.daily$DAY<-as.numeric(substr(davis.daily$DATE,7,8)) #simple field for day
  davis.daily<-davis.daily[,c("DATE2","JULIAN", "YEAR","MONTH","DAY","PRCP","TMAX","TMIN")] #simplified dataframe
  davis.yearlist<-split(davis.daily,davis.daily$YEAR) #list of each year separated
  #calculates the "day of year", i.e. Jan 1 is 1, and 12/31 is 365
  #adds a DAY.OF.YEAR column to each dataframe in the year list
  davis.yearnames<-unique(davis.daily$YEAR)
  for (i in 1:length(davis.yearnames)){
    davis.yearlist[[i]]$DAY.OF.YEAR<-julian(davis.yearlist[[i]]$DATE2, origin=as.Date(paste(davis.yearnames[i],"01","01",sep="-")))+1 #add +1 so that the first day of the year is 1, not zero.
  }
  yearlist.store=davis.yearlist
  goodyears=NULL
  for(iyear in davis.yearnames){
    nacount=sum(sum(is.na(davis.yearlist[[as.character(iyear)]])))
    daycount=dim(davis.yearlist[[as.character(iyear)]])[1]
    if(nacount==0 & daycount>364){goodyears=c(goodyears,iyear)}
  }
  davis.yearlist=davis.yearlist[as.character(goodyears)]
  davis.yearnames<-goodyears #gives a list of all the years in the data
  davis.daily<-unsplit(yearlist.store,davis.daily$YEAR) #using legacy "yearlist.store" to make unsplit happy
  # DAY.OF.YEAR=rep(0,dim(davis.daily)[1])
  # for(i in 1:length(DAY.OF.YEAR)){
  #   DAY.OF.YEAR[i]=sprintf("%02d%02d",davis.daily[i,"MONTH"],davis.daily[i,"DAY"])
  #
  # }
  # davis.daily=cbind(davis.daily, DAY.OF.YEAR)
  # davis.daily<-unsplit(davis.daily,davis.daily$YEAR)
  davis.daily.means<-aggregate(cbind(TMAX,TMIN,PRCP)~DAY.OF.YEAR, data=davis.daily[davis.daily$YEAR %in% goodyears,], mean)
  davis.yearvar<-data.frame(row.names=davis.yearnames) #dataframe to hold environmental variability
  for (i in 1:length(davis.yearnames)){
    #temporary dataframe to compare with mean conditions
    #this creates a VAR.x for each year and a VAR.y for the daily means
    comparison<-merge(davis.yearlist[[i]],davis.daily.means,by="DAY.OF.YEAR")
    #number of complete cases (is.na=F) for each year
    davis.yearvar[i,"TMAX.N"]<-sum(complete.cases(davis.yearlist[[i]]$TMAX))
    davis.yearvar[i,"TMIN.N"]<-sum(complete.cases(davis.yearlist[[i]]$TMIN))
    davis.yearvar[i,"PRCP.N"]<-sum(complete.cases(davis.yearlist[[i]]$PRCP))
    #sum of squared differences with an average year - how weird is each year?
    #some years have incomplete data, so this is the mean SS per observed day
    davis.yearvar[i,"TMAX.SS"]<-(sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)^2)/davis.yearvar[i,"TMAX.N"]
    davis.yearvar[i,"TMIN.SS"]<-(sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)^2)/davis.yearvar[i,"TMIN.N"]
    davis.yearvar[i,"PRCP.SS"]<-(sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)^2)/davis.yearvar[i,"PRCP.N"]
    #CV within years - how variable is each year?
    davis.yearvar[i,"TMAX.CV"]<-sd(comparison$TMAX.x,na.rm=T)/mean(comparison$TMAX.x,na.rm=T)
    davis.yearvar[i,"TMIN.CV"]<-sd(comparison$TMIN.x,na.rm=T)/mean(comparison$TMIN.x,na.rm=T)
    davis.yearvar[i,"PRCP.CV"]<-sd(comparison$PRCP.x,na.rm=T)/mean(comparison$PRCP.x,na.rm=T)
    #sum of differences (not squared) with an average year - how hot/wet is each year?
    #some years have incomplete data, so this is the mean difference per observed day
    davis.yearvar[i,"TMAX.DEL"]<-sum(comparison$TMAX.x-comparison$TMAX.y,na.rm=T)/davis.yearvar[i,"TMAX.N"]
    davis.yearvar[i,"TMIN.DEL"]<-sum(comparison$TMIN.x-comparison$TMIN.y,na.rm=T)/davis.yearvar[i,"TMIN.N"]
    davis.yearvar[i,"PRCP.DEL"]<-sum(comparison$PRCP.x-comparison$PRCP.y,na.rm=T)/davis.yearvar[i,"PRCP.N"]
    ######################
    # Fitness generation #
    ######################
    #For now, daily incremental fitness will be found by multiplying two gaussian functions together:
    #  one for temp, that's maximized at best.temp with sd tempsd
    #  the other for precip that's maximized at best.precip with sd precipsd
    # We will then normalize the results to vary from 0 to 1
    years.list=davis.yearlist
    for(i.year in 1:length(years.list)){
      newyear=years.list[[i.year]]
      newyear=newyear[,c("DAY.OF.YEAR","TMAX","PRCP")]
      colnames(newyear)<-c("day","tmax","precip")
      daily.fit=dnorm(newyear$tmax,mean=best.temp,sd=sd.temp)*dnorm(newyear$precip,mean=best.precip,sd=sd.precip)
      daily.fit=(daily.fit-min(daily.fit))/(max(daily.fit)-min(daily.fit))
      years.list[[i.year]]=cbind(newyear, fit.daily=daily.fit)
    }
    # Each year data frame has $day, $precip, $tmean, $tmax, $tmin
    # This will be the same list for all configurations of years - this is essentially just our year database
  }
  years.index=rep(c(1,2,3,4,5,6,7,8,9,10),length.out=numYears) # This is the list of which year.list data to use for each generation of the model
  years.list=davis.yearlist #Replace this with code to grab a list of data frames. Each data frame is a year.
  return(list("years.index"=years.index,"years.list"=years.list))
}
######################
# Plotting Functions #
######################

emergePlot<-function(indivs,traitName){
  #Function for plotting trait values through time
  #Inputs:
  #  generations: vector of the generation of each individual to be plotted
  #  traivals: vector of the trait value of interest of each individ to be plotted
  #  mainlabel: label for the main graph
  #  ylabel: label for Y axis
  maxCount=100 #maximum number of years to count
  generations=indivs[,"gen"]
  if(length(unique(generations))>maxCount){
    viewGens=floor(seq(min(generations),max(generations),length.out=maxCount))
    goodInd=generations %in% viewGens
    generations=generations[goodInd]
    indivs=indivs[goodInd,]
  }
  plot(jitter(generations),indivs[,traitName],type='n',
       main=paste("Actual effect size of",traitName),
       xlab="Generation",
       ylab=paste(traitName,"effect size"),
       cex.lab=1.4,cex.main=1.4)
  #Plot the "emerge before last day" indivs
  points(jitter(generations[indivs[,"emerge"]>364]),indivs[indivs[,"emerge"]>364,traitName],pch=3,col='blue')
  points(jitter(generations[indivs[,"emerge"]<365]),indivs[indivs[,"emerge"]<365,traitName],pch=1)
}
emergePlotYlim<-function(indivs,traitName,ylim){
  #Function for plotting trait values through time
  #Inputs:
  #  generations: vector of the generation of each individual to be plotted
  #  traivals: vector of the trait value of interest of each individ to be plotted
  #  mainlabel: label for the main graph
  #  ylabel: label for Y axis
  maxCount=100 #maximum number of years to count
  generations=indivs[,"gen"]
  if(length(unique(generations))>maxCount){
    viewGens=floor(seq(min(generations),max(generations),length.out=maxCount))
    goodInd=generations %in% viewGens
    generations=generations[goodInd]
    indivs=indivs[goodInd,]
  }
  plot(jitter(generations),indivs[,traitName],type='n',
       main=paste("Actual effect size of",traitName),
       xlab="Generation",
       ylab=paste(traitName,"effect size"),
       cex.lab=1.4,cex.main=1.4,
       ylim=ylim)
  #Plot the "emerge before last day" indivs
  points(jitter(generations[indivs[,"emerge"]>364]),indivs[indivs[,"emerge"]>364,traitName],pch=3,col='blue')
  points(jitter(generations[indivs[,"emerge"]<365]),indivs[indivs[,"emerge"]<365,traitName],pch=1)
}
traiteffplot<-function(indivs,traitName){
  #Function for plotting trait values through time
  #Inputs:
  #  generations: vector of the generation of each individual to be plotted
  #  traivals: vector of the trait value of interest of each individ to be plotted
  #  mainlabel: label for the main graph
  maxCount=100 #maximum number of years to count
  generations=indivs[,"gen"]
  if(length(unique(generations))>maxCount){
    viewGens=floor(seq(min(generations),max(generations),length.out=maxCount))
    goodInd=generations %in% viewGens
    generations=generations[goodInd]
    indivs=indivs[goodInd,]
  } #  ylabel: label for Y axis
  plot(jitter(indivs[,"gen"]),indivs[,traitName],pch=1,
       main=paste("Expected effect size of",traitName),
       xlab="Generation",
       ylab=paste(traitName,"effect size"),
       cex.lab=1.4,cex.main=1.4)
}
traitplot<-function(indivs,traitName){
  #Function for plotting trait values through time
  #Inputs:
  #  generations: vector of the generation of each individual to be plotted
  #  traivals: vector of the trait value of interest of each individ to be plotted
  #  mainlabel: label for the main graph
  #  ylabel: label for Y axis
  maxCount=100 #maximum number of years to count
  generations=indivs[,"gen"]
  if(length(unique(generations))>maxCount){
    viewGens=floor(seq(min(generations),max(generations),length.out=maxCount))
    goodInd=generations %in% viewGens
    generations=generations[goodInd]
    indivs=indivs[goodInd,]
  }
  plot(jitter(generations),indivs[,traitName],type='n',
       main=paste("Coefficient values of",traitName),
       xlab="Generation",
       ylab=paste(traitName,"values"),
       cex.lab=1.4,cex.main=1.4)
  #Plot the "emerge before last day" indivs
  points(jitter(generations[indivs[,"emerge"]>364]),indivs[indivs[,"emerge"]>364,traitName],pch=3,col='blue')
  points(jitter(generations[indivs[,"emerge"]<365]),indivs[indivs[,"emerge"]<365,traitName],pch=1)
}
