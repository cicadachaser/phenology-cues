header=FALSE))
fields1.undirweev.rad<-c(fields1.undirweev.rad,sum(mat[209:312,1:104]))
}
fields1.dirweev.rad <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fields1Farm_weevilsRadV%s_dir/fields1Farm_weevilsRadV%s_%s_dirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields1.dirweev.rad<-c(fields1.dirweev.rad,sum(mat[209:312,1:104]))
}
#################################
getOption("scipen")
opt <- options("scipen" = 20)
getOption("scipen")
x11()
par(mfrow=c(2,2),mar=c(6,6,4,4),oma=c(2,3,0,0))
yscaling=1000
x=(c(rep(4.3,30),rep(3.1,30),rep(1.9,30),rep(.7,30)))
y=c(fields1.dirweev.rad,fields4.dirweev.rad,fields16.dirweev.rad,fields64.dirweev.rad)
ymean=c(mean(fields1.dirweev.rad),mean(fields4.dirweev.rad),mean(fields16.dirweev.rad),mean(fields64.dirweev.rad))
barplot(rev(ymean)/yscaling,ylim=c(0,max(y/yscaling)*1.1),
main='(A) Directed, Inf Dispersal', ylab='',
names.arg=c('64 field','16 field','4 field','1 field'),cex.names=1.5,cex.lab=2,cex.main=1.8,cex.axis=1.8)
points(jitter(x,factor=.2),y/yscaling,pch=1)
x=(c(rep(4.3,30),rep(3.1,30),rep(1.9,30),rep(.7,30)))
y=c(fields1.undirweev.rad,fields4.undirweev.rad,fields16.undirweev.rad,fields64.undirweev.rad)
ymean=c(mean(fields1.undirweev.rad),mean(fields4.undirweev.rad),mean(fields16.undirweev.rad),mean(fields64.undirweev.rad))
barplot(rev(ymean)/yscaling,ylim=c(0,max(y/yscaling)*1.1),
main='(B) Undirected, Inf Dispersal',ylab='',
names.arg=c('64 field','16 field','4 field','1 field'),cex.names=1.5,cex.lab=2,cex.main=1.8,cex.axis=1.8)
points(jitter(x,factor=.3),y/yscaling,pch=1)
x=(c(rep(4.3,30),rep(3.1,30),rep(1.9,30),rep(.7,30)))
y=c(fields1.dirweev,fields4.dirweev,fields16.dirweev,fields64.dirweev)
ymean=c(mean(fields1.dirweev),mean(fields4.dirweev),mean(fields16.dirweev),mean(fields64.dirweev))
barplot(rev(ymean)/yscaling,ylim=c(0,max(y/yscaling)*1.1),
main=' (C) Directed, 100m Dispersal',ylab='',
names.arg=c('64 field','16 field','4 field','1 field'),cex.names=1.5,cex.lab=2,cex.main=1.8,cex.axis=1.8)
points(jitter(x,factor=.3),y/yscaling,pch=1)
x=(c(rep(4.3,30),rep(3.1,30),rep(1.9,30),rep(.7,30)))
y=c(fields1.undirweev,fields4.undirweev,fields16.undirweev,fields64.undirweev)
ymean=c(mean(fields1.undirweev),mean(fields4.undirweev),mean(fields16.undirweev),mean(fields64.undirweev))
barplot(rev(ymean)/yscaling,ylim=c(0,max(y/yscaling)*1.1),
main='(D) Undirected, 100m Dispersal', ylab='',
names.arg=c('64 field','16 field','4 field','1 field'),cex.names=1.5,cex.lab=1.5,cex.main=1.8,cex.axis=1.8)
points(jitter(x,factor=.3),y/yscaling,pch=1)
mtext('Weevil abundance (in thousands)',side=2,outer=TRUE,cex=2)
mtext('Aggregation level',side=1,outer=TRUE,cex=2)
#####
##Calculating effect size
#base=mean(fields64.dirweev.rad)
#new=mean(fields64.undirweev)
#new/base
#mean(fields64.dirweev.rad)
rm(list=ls())
vNum=10
###
#Standard Fields!
fields64.undirweev <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fieldsStand_weevilsStandV%s_dir/fieldsStand_weevilsStandV%s_%s_undirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields64.undirweev<-c(fields64.undirweev,sum(mat[209:312,1:104]))
}
fields64.dirweev <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fieldsStand_weevilsStandV%s_dir/fieldsStand_weevilsStandV%s_%s_dirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields64.dirweev<-c(fields64.dirweev,sum(mat[209:312,1:104]))
}
fields64.undirweev.rad <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fieldsStand_weevilsRadV%s_dir/fieldsStand_weevilsRadV%s_%s_undirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields64.undirweev.rad<-c(fields64.undirweev.rad,sum(mat[209:312,1:104]))
}
fields64.dirweev.rad <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fieldsStand_weevilsRadV%s_dir/fieldsStand_weevilsRadV%s_%s_dirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields64.dirweev.rad<-c(fields64.dirweev.rad,sum(mat[209:312,1:104]))
}
###
#Grouped fields!
fields16.undirweev <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fieldsGroupedFields_weevilsStandV%s_dir/fieldsGroupedFields_weevilsStandV%s_%s_undirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields16.undirweev<-c(fields16.undirweev,sum(mat[209:312,1:104]))
}
fields16.dirweev <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fieldsGroupedFields_weevilsStandV%s_dir/fieldsGroupedFields_weevilsStandV%s_%s_dirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields16.dirweev<-c(fields16.dirweev,sum(mat[209:312,1:104]))
}
fields16.undirweev.rad <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fieldsGroupedFields_weevilsRadV%s_dir/fieldsGroupedFields_weevilsRadV%s_%s_undirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields16.undirweev.rad<-c(fields16.undirweev.rad,sum(mat[209:312,1:104]))
}
fields16.dirweev.rad <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fieldsGroupedFields_weevilsRadV%s_dir/fieldsGroupedFields_weevilsRadV%s_%s_dirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields16.dirweev.rad<-c(fields16.dirweev.rad,sum(mat[209:312,1:104]))
}
###
#4 fields!
fields4.undirweev <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fields4Farms_weevilsStandV%s_dir/fields4Farms_weevilsStandV%s_%s_undirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields4.undirweev<-c(fields4.undirweev,sum(mat[209:312,1:104]))
}
fields4.dirweev <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fields4Farms_weevilsStandV%s_dir/fields4Farms_weevilsStandV%s_%s_dirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields4.dirweev<-c(fields4.dirweev,sum(mat[209:312,1:104]))
}
fields4.undirweev.rad <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fields4Farms_weevilsRadV%s_dir/fields4Farms_weevilsRadV%s_%s_undirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields4.undirweev.rad<-c(fields4.undirweev.rad,sum(mat[209:312,1:104]))
}
fields4.dirweev.rad <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fields4Farms_weevilsRadV%s_dir/fields4Farms_weevilsRadV%s_%s_dirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields4.dirweev.rad<-c(fields4.dirweev.rad,sum(mat[209:312,1:104]))
}
###
#1 field!
fields1.undirweev <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fields1Farm_weevilsStandV%s_dir/fields1Farm_weevilsStandV%s_%s_undirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields1.undirweev<-c(fields1.undirweev,sum(mat[209:312,1:104]))
}
fields1.dirweev <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fields1Farm_weevilsStandV%s_dir/fields1Farm_weevilsStandV%s_%s_dirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields1.dirweev<-c(fields1.dirweev,sum(mat[209:312,1:104]))
}
fields1.undirweev.rad <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fields1Farm_weevilsRadV%s_dir/fields1Farm_weevilsRadV%s_%s_undirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields1.undirweev.rad<-c(fields1.undirweev.rad,sum(mat[209:312,1:104]))
}
fields1.dirweev.rad <- NULL
for(i.run in 1:30){
mat=data.matrix(read.csv(sprintf("C:/Users/Collin/Documents/MATLAB/WorkingDir/fields1Farm_weevilsRadV%s_dir/fields1Farm_weevilsRadV%s_%s_dirWeevils.csv",vNum,vNum,i.run),
header=FALSE))
fields1.dirweev.rad<-c(fields1.dirweev.rad,sum(mat[209:312,1:104]))
}
#################################
getOption("scipen")
opt <- options("scipen" = 20)
getOption("scipen")
x11()
par(mfrow=c(2,2),mar=c(6,6,4,4),oma=c(2,3,0,0))
yscaling=1000
x=(c(rep(4.3,30),rep(3.1,30),rep(1.9,30),rep(.7,30)))
y=c(fields1.dirweev.rad,fields4.dirweev.rad,fields16.dirweev.rad,fields64.dirweev.rad)
ymean=c(mean(fields1.dirweev.rad),mean(fields4.dirweev.rad),mean(fields16.dirweev.rad),mean(fields64.dirweev.rad))
barplot(rev(ymean)/yscaling,ylim=c(0,max(y/yscaling)*1.1),
main='(A) Directed, Inf Dispersal', ylab='',
names.arg=c('64 field','16 field','4 field','1 field'),cex.names=1.5,cex.lab=2,cex.main=1.8,cex.axis=1.8)
points(jitter(x,factor=.2),y/yscaling,pch=1)
x=(c(rep(4.3,30),rep(3.1,30),rep(1.9,30),rep(.7,30)))
y=c(fields1.undirweev.rad,fields4.undirweev.rad,fields16.undirweev.rad,fields64.undirweev.rad)
ymean=c(mean(fields1.undirweev.rad),mean(fields4.undirweev.rad),mean(fields16.undirweev.rad),mean(fields64.undirweev.rad))
barplot(rev(ymean)/yscaling,ylim=c(0,max(y/yscaling)*1.1),
main='(B) Undirected, Inf Dispersal',ylab='',
names.arg=c('64 field','16 field','4 field','1 field'),cex.names=1.5,cex.lab=2,cex.main=1.8,cex.axis=1.8)
points(jitter(x,factor=.3),y/yscaling,pch=1)
x=(c(rep(4.3,30),rep(3.1,30),rep(1.9,30),rep(.7,30)))
y=c(fields1.dirweev,fields4.dirweev,fields16.dirweev,fields64.dirweev)
ymean=c(mean(fields1.dirweev),mean(fields4.dirweev),mean(fields16.dirweev),mean(fields64.dirweev))
barplot(rev(ymean)/yscaling,ylim=c(0,max(y/yscaling)*1.1),
main=' (C) Directed, 100m Dispersal',ylab='',
names.arg=c('64 field','16 field','4 field','1 field'),cex.names=1.5,cex.lab=2,cex.main=1.8,cex.axis=1.8)
points(jitter(x,factor=.3),y/yscaling,pch=1)
x=(c(rep(4.3,30),rep(3.1,30),rep(1.9,30),rep(.7,30)))
y=c(fields1.undirweev,fields4.undirweev,fields16.undirweev,fields64.undirweev)
ymean=c(mean(fields1.undirweev),mean(fields4.undirweev),mean(fields16.undirweev),mean(fields64.undirweev))
barplot(rev(ymean)/yscaling,ylim=c(0,max(y/yscaling)*1.1),
main='(D) Undirected, 100m Dispersal', ylab='',
names.arg=c('64 field','16 field','4 field','1 field'),cex.names=1.5,cex.lab=1.5,cex.main=1.8,cex.axis=1.8)
points(jitter(x,factor=.3),y/yscaling,pch=1)
mtext('Weevil abundance (in thousands)',side=2,outer=TRUE,cex=2)
mtext('Aggregation level',side=1,outer=TRUE,cex=2)
#####
##Calculating effect size
#base=mean(fields64.dirweev.rad)
#new=mean(fields64.undirweev)
#new/base
#mean(fields64.dirweev.rad)
#CURRENTLY IN THE "SLOW AND CORRECT" STAGE
#optimize AFTER we confirm it works
#clear all variables
rm(list=ls())
set_wrkdir<-function(){
#function for setting working directory to the right place given the current computer/user
if(Sys.getenv("USERNAME")=="Collin" || Sys.getenv("USERNAME")=="collin" || Sys.getenv("USERNAME")=="Collin.work"){ #If it's collin
if(Sys.info()[1]=="Linux"){
setwd("/home/collin/Dropbox/Grad school/research projects/yang_cue")
}else{
if(Sys.info()["nodename"]=="DESKTOP-D6QSU8F"){
setwd("G:\\Repos\\phenology-cues") #desktop
}else{
setwd("C:\\Repos\\phenology-cues") #desktop
}
}
}else{
if(Sys.getenv("COMPUTERNAME")=="ENT-YANG01"){
setwd("C:\\Users\\lhyang.ent-yang01\\SkyDrive\\Phenology simulation\\phenology-cues")#desktop
}else{
setwd("C:\\Users\\lhyang\\Skydrive\\Phenology simulation\\phenology-cues")} #laptop
}
}
ptm <-proc.time()
#########################
# Simulation parameters #
#########################
runType="unitTestConst" ##THIS DETERMINES WHAT KIND OF YEARS WE'RE USING!
#unitTestConst is for running the population through a unit test with the same gaussian fitness every year
#and constant environmental conditions
#unitTestRand will be for running the populations through a
#unit test with the same gaussian fitness every year and random envi conditions
#standard is for running the populations through a set of replications of the first 10 good years of the davis data
runName="quickTest" #string without spaces (for simplicity)
duration=10
N=100 #number of individuals
numYears=1500
best.temp=15; sd.temp=10; #The optimal temp and the sd for the temp-by-fitness curve (which is gaussian)
best.precip=55; sd.precip=30; #The optimal precip and the sd for the precip-by-fitness curve (which is gaussian)
start<-data.frame(  #this represents the min and max values used when randomly assigning initial values to the population
daymin=0,daymax=100,
tempmin=0,tempmax=10,
precipmin=0,precipmax=10)
sds<-data.frame( #standard deviations for trait mutations. Currently set so that variance = max initial trait value
day=sqrt(start$daymax)/10,
temp=sqrt(start$tempmax)/10,
precip=sqrt(start$precipmax)/10)
mutrate<-data.frame( #probability of each trait mutating in an individual. Mutations are independent of one another
const=.1,
day=.1,
temp=.1,
precip=.1)
years.index=rep(1:100,length.out=numYears) # This is the list of which year.list data to use for each generation of the model
#######################################
# Handling libraries and source files #
#######################################
#libraries
library(timeDate)
# library(Cairo) #I'm not sure if we need this with the plotting removed
library(zoo)
#Set appropriate working directory
set_wrkdir()
#Load sources file(s)
source("windows_subs.R")
###############################
# Generate environmental data #
###############################
#Based on the value of "runType", generate the appropriate type of data.
if(runType=="standard"){
out=yeargen.davistest(numYears,best.temp = best.temp,sd.temp = sd.temp,
best.precip = best.precip,sd.precip = sd.precip)
years.list=out[["years.list"]]
} else if(runType=="unitTestConst"){
out=yeargen.const(numYears)
years.list=out[["years.list"]]
} else if (runType=="unitTestRand"){
out=yeargen.rand(numYears)
years.list=out[["years.list"]]
}
#######################
# initializing population
#######################
##intialize a population of N individuals
# Their min and max values are determined by the start$ parameters
b.day<-runif(n=N,min=start$daymin,max=start$daymax)
b.temp<-runif(n=N,min=start$tempmin,max=start$tempmax)
b.precip<-runif(n=N,min=start$precipmin,max=start$precipmax)
newpop<-data.frame(b.day,b.temp,b.precip)
pop<-selection(newpop,duration,year=years.list[[1]],N)
###########################
## Running the Simulation #
###########################
pophistory=runSim(startpop=pop,years.list=years.list,
years.ind=years.index,N=N,duration=duration,
sds=sds,mutrate=mutrate,generations=length(years.index[-1]))
#Note: we've already used year 1 in initiating the pop
#####################
#Saving our results #
#####################
#Set appropriate working directory
set_wrkdir()
#We have a "save data" script called windows_save.R
source("windows_save.R")
############
# Plotting #
############
set_wrkdir()
source("windows_plot.R")
proc.time()-ptm
temp=yeargen.rand(100)
temp[[2]]
temp[[3]]
temp[[1]]
temp[[1]][[2]]
years.list[[2]]
#CURRENTLY IN THE "SLOW AND CORRECT" STAGE
#optimize AFTER we confirm it works
#clear all variables
rm(list=ls())
set_wrkdir<-function(){
#function for setting working directory to the right place given the current computer/user
if(Sys.getenv("USERNAME")=="Collin" || Sys.getenv("USERNAME")=="collin" || Sys.getenv("USERNAME")=="Collin.work"){ #If it's collin
if(Sys.info()[1]=="Linux"){
setwd("/home/collin/Dropbox/Grad school/research projects/yang_cue")
}else{
if(Sys.info()["nodename"]=="DESKTOP-D6QSU8F"){
setwd("G:\\Repos\\phenology-cues") #desktop
}else{
setwd("C:\\Repos\\phenology-cues") #desktop
}
}
}else{
if(Sys.getenv("COMPUTERNAME")=="ENT-YANG01"){
setwd("C:\\Users\\lhyang.ent-yang01\\SkyDrive\\Phenology simulation\\phenology-cues")#desktop
}else{
setwd("C:\\Users\\lhyang\\Skydrive\\Phenology simulation\\phenology-cues")} #laptop
}
}
ptm <-proc.time()
#########################
# Simulation parameters #
#########################
runType="unitTestConst" ##THIS DETERMINES WHAT KIND OF YEARS WE'RE USING!
#unitTestConst is for running the population through a unit test with the same gaussian fitness every year
#and constant environmental conditions
#unitTestRand will be for running the populations through a
#unit test with the same gaussian fitness every year and random envi conditions
#standard is for running the populations through a set of replications of the first 10 good years of the davis data
runName="quickTest" #string without spaces (for simplicity)
duration=10
N=100 #number of individuals
numYears=1500
best.temp=15; sd.temp=10; #The optimal temp and the sd for the temp-by-fitness curve (which is gaussian)
best.precip=55; sd.precip=30; #The optimal precip and the sd for the precip-by-fitness curve (which is gaussian)
start<-data.frame(  #this represents the min and max values used when randomly assigning initial values to the population
daymin=0,daymax=100,
tempmin=0,tempmax=10,
precipmin=0,precipmax=10)
sds<-data.frame( #standard deviations for trait mutations. Currently set so that variance = max initial trait value
day=sqrt(start$daymax)/10,
temp=sqrt(start$tempmax)/10,
precip=sqrt(start$precipmax)/10)
mutrate<-data.frame( #probability of each trait mutating in an individual. Mutations are independent of one another
const=.1,
day=.1,
temp=.1,
precip=.1)
years.index=rep(1:100,length.out=numYears) # This is the list of which year.list data to use for each generation of the model
#######################################
# Handling libraries and source files #
#######################################
#libraries
library(timeDate)
# library(Cairo) #I'm not sure if we need this with the plotting removed
library(zoo)
#Set appropriate working directory
set_wrkdir()
#Load sources file(s)
source("windows_subs.R")
###############################
# Generate environmental data #
###############################
#Based on the value of "runType", generate the appropriate type of data.
if(runType=="standard"){
out=yeargen.davistest(numYears,best.temp = best.temp,sd.temp = sd.temp,
best.precip = best.precip,sd.precip = sd.precip)
years.list=out[["years.list"]]
} else if(runType=="unitTestConst"){
out=yeargen.const(numYears)
years.list=out[["years.list"]]
} else if (runType=="unitTestRand"){
out=yeargen.rand(numYears)
years.list=out[["years.list"]]
}
years.list[[2]]
out=yeargen.rand(numYears)
numYears
out=yeargen.const(numYears)
out
years.list=out[["years.list"]]
years.list[[2]]
#CURRENTLY IN THE "SLOW AND CORRECT" STAGE
#optimize AFTER we confirm it works
#clear all variables
rm(list=ls())
set_wrkdir<-function(){
#function for setting working directory to the right place given the current computer/user
if(Sys.getenv("USERNAME")=="Collin" || Sys.getenv("USERNAME")=="collin" || Sys.getenv("USERNAME")=="Collin.work"){ #If it's collin
if(Sys.info()[1]=="Linux"){
setwd("/home/collin/Dropbox/Grad school/research projects/yang_cue")
}else{
if(Sys.info()["nodename"]=="DESKTOP-D6QSU8F"){
setwd("G:\\Repos\\phenology-cues") #desktop
}else{
setwd("C:\\Repos\\phenology-cues") #desktop
}
}
}else{
if(Sys.getenv("COMPUTERNAME")=="ENT-YANG01"){
setwd("C:\\Users\\lhyang.ent-yang01\\SkyDrive\\Phenology simulation\\phenology-cues")#desktop
}else{
setwd("C:\\Users\\lhyang\\Skydrive\\Phenology simulation\\phenology-cues")} #laptop
}
}
ptm <-proc.time()
#########################
# Simulation parameters #
#########################
runType="unitTestConst" ##THIS DETERMINES WHAT KIND OF YEARS WE'RE USING!
#unitTestConst is for running the population through a unit test with the same gaussian fitness every year
#and constant environmental conditions
#unitTestRand will be for running the populations through a
#unit test with the same gaussian fitness every year and random envi conditions
#standard is for running the populations through a set of replications of the first 10 good years of the davis data
runName="quickTest" #string without spaces (for simplicity)
duration=10
N=100 #number of individuals
numYears=1500
best.temp=15; sd.temp=10; #The optimal temp and the sd for the temp-by-fitness curve (which is gaussian)
best.precip=55; sd.precip=30; #The optimal precip and the sd for the precip-by-fitness curve (which is gaussian)
start<-data.frame(  #this represents the min and max values used when randomly assigning initial values to the population
daymin=0,daymax=100,
tempmin=0,tempmax=10,
precipmin=0,precipmax=10)
sds<-data.frame( #standard deviations for trait mutations. Currently set so that variance = max initial trait value
day=sqrt(start$daymax)/10,
temp=sqrt(start$tempmax)/10,
precip=sqrt(start$precipmax)/10)
mutrate<-data.frame( #probability of each trait mutating in an individual. Mutations are independent of one another
const=.1,
day=.1,
temp=.1,
precip=.1)
years.index=rep(1:100,length.out=numYears) # This is the list of which year.list data to use for each generation of the model
#######################################
# Handling libraries and source files #
#######################################
#libraries
library(timeDate)
# library(Cairo) #I'm not sure if we need this with the plotting removed
library(zoo)
#Set appropriate working directory
set_wrkdir()
#Load sources file(s)
source("windows_subs.R")
###############################
# Generate environmental data #
###############################
#Based on the value of "runType", generate the appropriate type of data.
if(runType=="standard"){
out=yeargen.davistest(numYears,best.temp = best.temp,sd.temp = sd.temp,
best.precip = best.precip,sd.precip = sd.precip)
years.list=out[["years.list"]]
} else if(runType=="unitTestConst"){
out=yeargen.const(numYears)
years.list=out[["years.list"]]
years.index=rep(1,numYears)
} else if (runType=="unitTestRand"){
out=yeargen.rand(numYears)
years.list=out[["years.list"]]
}
#######################
# initializing population
#######################
##intialize a population of N individuals
# Their min and max values are determined by the start$ parameters
b.day<-runif(n=N,min=start$daymin,max=start$daymax)
b.temp<-runif(n=N,min=start$tempmin,max=start$tempmax)
b.precip<-runif(n=N,min=start$precipmin,max=start$precipmax)
newpop<-data.frame(b.day,b.temp,b.precip)
pop<-selection(newpop,duration,year=years.list[[1]],N)
###########################
## Running the Simulation #
###########################
pophistory=runSim(startpop=pop,years.list=years.list,
years.ind=years.index,N=N,duration=duration,
sds=sds,mutrate=mutrate,generations=length(years.index[-1]))
#Note: we've already used year 1 in initiating the pop
#####################
#Saving our results #
#####################
#Set appropriate working directory
set_wrkdir()
#We have a "save data" script called windows_save.R
source("windows_save.R")
############
# Plotting #
############
set_wrkdir()
source("windows_plot.R")
proc.time()-ptm
